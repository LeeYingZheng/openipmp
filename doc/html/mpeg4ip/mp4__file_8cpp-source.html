<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>&quot;MPEG4IP with DRM support&quot;: mp4_file.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>mp4_file.cpp</h1><a href="mp4__file_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00006 <span class="comment">/*</span>
00007 <span class="comment"> * The contents of this file are subject to the Mozilla Public</span>
00008 <span class="comment"> * License Version 1.1 (the "License"); you may not use this file</span>
00009 <span class="comment"> * except in compliance with the License. You may obtain a copy of</span>
00010 <span class="comment"> * the License at http://www.mozilla.org/MPL/</span>
00011 <span class="comment"> * </span>
00012 <span class="comment"> * Software distributed under the License is distributed on an "AS</span>
00013 <span class="comment"> * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or</span>
00014 <span class="comment"> * implied. See the License for the specific language governing</span>
00015 <span class="comment"> * rights and limitations under the License.</span>
00016 <span class="comment"> * </span>
00017 <span class="comment"> * The Original Code is MPEG4IP.</span>
00018 <span class="comment"> * </span>
00019 <span class="comment"> * The Initial Developer of the Original Code is Cisco Systems Inc.</span>
00020 <span class="comment"> * Portions created by Cisco Systems Inc. are</span>
00021 <span class="comment"> * Copyright (C) Cisco Systems Inc. 2000, 2001.  All Rights Reserved.</span>
00022 <span class="comment"> * </span>
00023 <span class="comment"> * Contributor(s): </span>
00024 <span class="comment"> *              Bill May        wmay@cisco.com</span>
00025 <span class="comment"> */</span>
00026 <span class="comment">/*</span>
00027 <span class="comment"> * qtime_file.cpp - provides generic class for quicktime file access control.</span>
00028 <span class="comment"> * file access is then used by quicktime audio and video bytestreams.</span>
00029 <span class="comment"> */</span>
00030 <span class="preprocessor">#include "mpeg4ip.h"</span>
00031 <span class="preprocessor">#include "player_session.h"</span>
00032 <span class="preprocessor">#include "player_media.h"</span>
00033 <span class="preprocessor">#include "player_util.h"</span>
00034 <span class="preprocessor">#include "media_utils.h"</span>
00035 <span class="preprocessor">#include &lt;mp4.h&gt;</span>
00036 <span class="preprocessor">#include "mp4_bytestream.h"</span>
00037 <span class="preprocessor">#include "mp4_file.h"</span>
00038 <span class="preprocessor">#include &lt;mp4util/mpeg4_audio_config.h&gt;</span>
00039 <span class="preprocessor">#include "our_config_file.h"</span>
00040 <span class="preprocessor">#include "codec_plugin_private.h"</span>
00041 <span class="preprocessor">#include &lt;ismacryplib.h&gt;</span>
00042 
00043 <span class="preprocessor">#include "<a class="code" href="mp4__drm__bytestream_8h.html">mp4_drm_bytestream.h</a>"</span>
00044 
00045 <span class="comment">/*</span>
00046 <span class="comment"> * Create the media for the quicktime file, and set up some session stuff.</span>
00047 <span class="comment"> */</span>
00048 <span class="keyword">static</span> <span class="keywordtype">void</span> close_mp4_file (<span class="keywordtype">void</span> *data)
00049 {
00050   CMp4File *Mp4File1 = (CMp4File *)data;
00051   <span class="keywordflow">if</span> (Mp4File1 != NULL) {
00052     <span class="keyword">delete</span> Mp4File1;
00053     Mp4File1 = NULL;
00054   }
00055 }
00056 
00057 <span class="keywordtype">int</span> create_media_for_mp4_file (CPlayerSession *psptr, 
00058                                <span class="keyword">const</span> <span class="keywordtype">char</span> *name,
00059                                <span class="keywordtype">int</span> have_audio_driver,
00060                                control_callback_vft_t *cc_vft)
00061 {
00062   MP4FileHandle fh;
00063   CMp4File *Mp4File1;
00064 
00065   fh = MP4Read(name, MP4_DETAILS_ERROR); <span class="comment">// | MP4_DETAILS_READ | MP4_DETAILS_SAMPLE);</span>
00066   <span class="keywordflow">if</span> (!MP4_IS_VALID_FILE_HANDLE(fh)) {
00067     psptr-&gt;set_message(<span class="stringliteral">"`%s\' is not an mp4 file"</span>, name);
00068     <span class="keywordflow">return</span> -1;
00069   }
00070 
00071   Mp4File1 = <span class="keyword">new</span> CMp4File(fh);
00072   <span class="comment">// quicktime is searchable...</span>
00073   psptr-&gt;set_media_close_callback(close_mp4_file, (<span class="keywordtype">void</span> *)Mp4File1);
00074   psptr-&gt;session_set_seekable(1);
00075 
00076   <span class="keywordtype">int</span> ret;
00077   ret = Mp4File1-&gt;create_media(psptr, 
00078                                have_audio_driver,
00079                                cc_vft);
00080   <span class="keywordflow">if</span> (ret &lt;= 0) <span class="keywordflow">return</span> ret;
00081 
00082   uint offset = 0;
00083 
00084   <span class="keywordtype">char</span> errmsg[512];
00085   uint32_t errlen = <span class="keyword">sizeof</span>(errmsg) - 1;
00086   errmsg[0] = <span class="charliteral">'\0'</span>;
00087   <span class="keywordflow">if</span> (Mp4File1-&gt;get_illegal_video_codec() != 0) {
00088     offset = snprintf(errmsg, errlen, <span class="stringliteral">"Unknown or unused Video tracks "</span>);
00089   }
00090 
00091   <span class="keywordflow">if</span> (have_audio_driver == 0) {
00092     offset += snprintf(errmsg + offset, errlen - offset, 
00093                        <span class="stringliteral">"%sNo Audio driver - can't play audio"</span>,
00094                        offset == 0 ? <span class="stringliteral">""</span> : <span class="stringliteral">"and "</span>);
00095   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (Mp4File1-&gt;get_illegal_audio_codec() != 0) {
00096     snprintf(errmsg + offset, errlen - offset, 
00097              <span class="stringliteral">"%sUnknown or unused audio tracks"</span>, 
00098              offset == 0 ? <span class="stringliteral">""</span> : <span class="stringliteral">"and "</span>);
00099   }
00100   psptr-&gt;set_message(errmsg);
00101   <span class="keywordflow">return</span> (1);
00102 }
00103 
00104 CMp4File::CMp4File (MP4FileHandle filehandle)
00105 {
00106   m_mp4file = filehandle;
00107   m_file_mutex = SDL_CreateMutex();
00108   m_illegal_audio_codec = 0;
00109   m_illegal_video_codec = 0;
00110   m_illegal_text_codec = 0;
00111   m_have_audio = <span class="keyword">false</span>;
00112 }
00113 
00114 CMp4File::~CMp4File (<span class="keywordtype">void</span>)
00115 {
00116   MP4Close(m_mp4file);
00117   m_mp4file = NULL;
00118   <span class="keywordflow">if</span> (m_file_mutex) {
00119     SDL_DestroyMutex(m_file_mutex);
00120     m_file_mutex = NULL;
00121   }
00122 }
00123 
00124 <span class="keywordtype">int</span> CMp4File::create_video(CPlayerSession *psptr, 
00125                            video_query_t *vq, 
00126                            uint video_offset,
00127                            uint &amp;start_desc)
00128 {
00129   uint ix;
00130   CPlayerMedia *mptr;
00131   codec_plugin_t *plugin;
00132 
00133   <span class="keywordflow">for</span> (ix = 0; ix &lt; video_offset; ix++) {
00134     <span class="keywordflow">if</span> (vq[ix].enabled != 0) {
00135 
00136       mptr = <span class="keyword">new</span> CPlayerMedia(psptr, VIDEO_SYNC);
00137       <span class="keywordflow">if</span> (mptr == NULL) {
00138         <span class="keywordflow">return</span> (-1);
00139       }
00140                                                   
00141       video_info_t *vinfo;
00142       vinfo = (video_info_t *)malloc(<span class="keyword">sizeof</span>(video_info_t));
00143       vinfo-&gt;height = vq[ix].h;
00144       vinfo-&gt;width = vq[ix].w;
00145       plugin = check_for_video_codec(vq[ix].stream_type,
00146                                      vq[ix].compressor,
00147                                      NULL,
00148                                      vq[ix].type,
00149                                      vq[ix].profile,
00150                                      vq[ix].config, 
00151                                      vq[ix].config_len,
00152                                      &amp;config);
00153 
00154       <span class="keywordtype">int</span> ret = mptr-&gt;create_video_plugin(plugin, 
00155                                           vq[ix].stream_type,
00156                                           vq[ix].compressor,
00157                                           vq[ix].type,
00158                                           vq[ix].profile,
00159                                           NULL, <span class="comment">// sdp info</span>
00160                                           vinfo, <span class="comment">// video info</span>
00161                                           vq[ix].config,
00162                                           vq[ix].config_len);
00163 
00164       <span class="keywordflow">if</span> (ret &lt; 0) {
00165         mp4f_message(LOG_ERR, <span class="stringliteral">"Failed to create plugin data"</span>);
00166         psptr-&gt;set_message(<span class="stringliteral">"Failed to start plugin"</span>);
00167         <span class="keyword">delete</span> mptr;
00168         <span class="keywordflow">return</span> -1;
00169       }
00170 
00171       CMp4VideoByteStream *vbyte;
00172      
00173       uint32_t verb = MP4GetVerbosity(m_mp4file);
00174       MP4SetVerbosity(m_mp4file, verb &amp; ~(MP4_DETAILS_ERROR));
00175       <span class="keywordflow">if</span> (strcasecmp(vq[ix].compressor, <span class="stringliteral">"avc1"</span>) == 0) {
00176         vbyte = <span class="keyword">new</span> CMp4H264VideoByteStream(<span class="keyword">this</span>, vq[ix].track_id);
00177       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcasecmp(vq[ix].compressor, <span class="stringliteral">"encv"</span>) == 0) {
00178   <span class="comment">//  BEGIN  Added for DRM support.</span>
00179         vbyte = <span class="keyword">new</span> <a class="code" href="class_c_mp4_d_r_m_video_byte_stream.html">CMp4DRMVideoByteStream</a>(<span class="keyword">this</span>, vq[ix].track_id);
00180   <span class="comment">//  END    Added for DRM support.</span>
00181       } <span class="keywordflow">else</span> {
00182         vbyte = <span class="keyword">new</span> CMp4VideoByteStream(<span class="keyword">this</span>, vq[ix].track_id);
00183       }
00184       MP4SetVerbosity(m_mp4file, verb);
00185 
00186       <span class="keywordflow">if</span> (vbyte == NULL) {
00187         <span class="keyword">delete</span> mptr;
00188         <span class="keywordflow">return</span> (-1);
00189       }
00190 
00191       ret = mptr-&gt;create_media(<span class="stringliteral">"video"</span>, vbyte);
00192       <span class="keywordflow">if</span> (ret != 0) {
00193         <span class="keywordflow">return</span> (-1);
00194       }
00195       MP4SetVerbosity(m_mp4file, verb &amp; ~(MP4_DETAILS_ERROR));
00196       <span class="keywordtype">char</span> *mp4info = MP4Info(m_mp4file, vq[ix].track_id);
00197       MP4SetVerbosity(m_mp4file, verb);
00198       <span class="keywordtype">char</span> *temp = mp4info;
00199       <span class="keywordflow">while</span> (*temp != <span class="charliteral">'\0'</span>) {
00200         <span class="keywordflow">if</span> (isspace(*temp)) *temp = <span class="charliteral">' '</span>;
00201         <span class="keywordflow">if</span> (!isprint(*temp)) *temp = <span class="charliteral">'*'</span>;
00202         temp++;
00203       }
00204       psptr-&gt;set_session_desc(start_desc, mp4info);
00205       free(mp4info);
00206       start_desc++;
00207     } <span class="keywordflow">else</span> {
00208       <span class="keywordflow">if</span> (vq[ix].config != NULL) free((<span class="keywordtype">void</span> *)vq[ix].config);
00209     }
00210   }
00211   <span class="keywordflow">return</span> 0;
00212 }
00213 
00214 <span class="keywordtype">int</span> CMp4File::create_audio(CPlayerSession *psptr, 
00215                            audio_query_t *aq, 
00216                            uint audio_offset,
00217                            uint &amp;start_desc)
00218 {
00219   uint ix;
00220   CPlayerMedia *mptr;
00221   codec_plugin_t *plugin;
00222   <span class="keywordflow">for</span> (ix = 0; ix &lt; audio_offset; ix++) {
00223     <span class="keywordflow">if</span> (aq[ix].enabled != 0) {
00224       CMp4AudioByteStream *abyte;
00225       mptr = <span class="keyword">new</span> CPlayerMedia(psptr, AUDIO_SYNC);
00226       <span class="keywordflow">if</span> (mptr == NULL) {
00227         <span class="keywordflow">return</span> (-1);
00228       }
00229 
00230       uint32_t verb = MP4GetVerbosity(m_mp4file);
00231       MP4SetVerbosity(m_mp4file, verb &amp; ~(MP4_DETAILS_ERROR));
00232       <span class="keywordflow">if</span> (strcasecmp(aq[ix].compressor, <span class="stringliteral">"enca"</span>) == 0) {
00233   <span class="comment">//  BEGIN  Added for DRM support.</span>
00234         abyte = <span class="keyword">new</span> <a class="code" href="class_c_mp4_d_r_m_audio_byte_stream.html#a0">CMp4DRMAudioByteStream</a>(<span class="keyword">this</span>, aq[ix].track_id);
00235   <span class="comment">//  END    Added for DRM support.</span>
00236       } <span class="keywordflow">else</span> {
00237         abyte = <span class="keyword">new</span> CMp4AudioByteStream(<span class="keyword">this</span>, aq[ix].track_id);
00238       }
00239       MP4SetVerbosity(m_mp4file, verb);
00240 
00241       audio_info_t *ainfo;
00242       ainfo = (audio_info_t *)malloc(<span class="keyword">sizeof</span>(audio_info_t));
00243       memset(ainfo, 0, <span class="keyword">sizeof</span>(*ainfo));
00244 
00245       ainfo-&gt;freq = aq[ix].sampling_freq;
00246       <span class="keywordflow">if</span> (aq[ix].chans != -1) {
00247         ainfo-&gt;chans = aq[ix].chans;
00248       }
00249       <span class="keywordflow">if</span> ((aq[ix].type == MP4_PCM16_LITTLE_ENDIAN_AUDIO_TYPE) ||
00250           (aq[ix].type == MP4_PCM16_BIG_ENDIAN_AUDIO_TYPE)) {
00251         ainfo-&gt;bitspersample = 16;
00252       }
00253 
00254       <span class="keywordtype">int</span> ret;
00255       plugin = check_for_audio_codec(STREAM_TYPE_MP4_FILE,
00256                                      aq[ix].compressor, <span class="comment">// media_data field</span>
00257                                      NULL,
00258                                      aq[ix].type,
00259                                      aq[ix].profile,
00260                                      aq[ix].config,
00261                                      aq[ix].config_len,
00262                                      &amp;config);
00263 
00264       ret = mptr-&gt;create_audio_plugin(plugin,
00265                                       STREAM_TYPE_MP4_FILE,
00266                                       aq[ix].compressor,
00267                                       aq[ix].type, 
00268                                       aq[ix].profile,
00269                                       NULL, <span class="comment">// sdp info</span>
00270                                       ainfo, <span class="comment">// audio info</span>
00271                                       aq[ix].config,
00272                                       aq[ix].config_len);
00273       <span class="keywordflow">if</span> (ret &lt; 0) {
00274         mp4f_message(LOG_ERR, <span class="stringliteral">"Couldn't create audio from plugin %s"</span>, 
00275                      plugin-&gt;c_name);
00276         psptr-&gt;set_message(<span class="stringliteral">"Couldn't start audio plugin %s"</span>, 
00277                            plugin-&gt;c_name);
00278         <span class="keyword">delete</span> mptr;
00279         <span class="keyword">delete</span> abyte;
00280         <span class="keywordflow">return</span> -1;
00281       }
00282 
00283       ret = mptr-&gt;create_media(<span class="stringliteral">"audio"</span>, abyte);
00284       <span class="keywordflow">if</span> (ret != 0) {
00285         <span class="keywordflow">return</span> (-1);
00286       }
00287       MP4SetVerbosity(m_mp4file, verb &amp; ~(MP4_DETAILS_ERROR));
00288       <span class="keywordtype">char</span> *mp4info = MP4Info(m_mp4file, aq[ix].track_id);
00289       MP4SetVerbosity(m_mp4file, verb);
00290       <span class="keywordtype">char</span> *temp = mp4info;
00291       <span class="keywordflow">while</span> (*temp != <span class="charliteral">'\0'</span>) {
00292         <span class="keywordflow">if</span> (isspace(*temp)) *temp = <span class="charliteral">' '</span>;
00293         <span class="keywordflow">if</span> (!isprint(*temp)) *temp = <span class="charliteral">'*'</span>;
00294         temp++;
00295       }
00296       psptr-&gt;set_session_desc(start_desc, mp4info);
00297       free(mp4info);
00298       start_desc++;
00299     } <span class="keywordflow">else</span> {
00300       <span class="keywordflow">if</span> (aq[ix].config != NULL) free((<span class="keywordtype">void</span> *)aq[ix].config);
00301     }
00302   }
00303 
00304   <span class="keywordflow">return</span> 0;
00305 }
00306 
00307 <span class="keywordtype">int</span> CMp4File::create_text(CPlayerSession *psptr, 
00308                            text_query_t *tq, 
00309                            uint text_offset,
00310                            uint &amp;start_desc)
00311 {
00312   uint ix;
00313   <span class="comment">//uint64_t IVLength;</span>
00314   CPlayerMedia *mptr;
00315   codec_plugin_t *plugin;
00316   uint32_t verb = MP4GetVerbosity(m_mp4file);
00317   <span class="keywordflow">for</span> (ix = 0; ix &lt; text_offset; ix++) {
00318     <span class="keywordflow">if</span> (tq[ix].enabled != 0) {
00319       CMp4TextByteStream *tbyte;
00320       mptr = <span class="keyword">new</span> CPlayerMedia(psptr, TIMED_TEXT_SYNC);
00321       <span class="keywordflow">if</span> (mptr == NULL) {
00322         <span class="keywordflow">return</span> (-1);
00323       }
00324 
00325       <span class="comment">/* check if ismacryp */</span>
00326 <span class="preprocessor">#if 0</span>
00327 <span class="preprocessor"></span>      uint32_t verb = MP4GetVerbosity(m_mp4file);
00328       MP4SetVerbosity(m_mp4file, verb &amp; ~(MP4_DETAILS_ERROR));
00329       <span class="keywordflow">if</span> (MP4IsIsmaCrypMediaTrack(m_mp4file, aq[ix].track_id)) {
00330         IVLength = MP4GetTrackIntegerProperty(m_mp4file,
00331                     aq[ix].track_id, <span class="stringliteral">"mdia.minf.stbl.stsd.enca.sinf.schi.iSFM.IV-length"</span>);
00332         abyte = <span class="keyword">new</span> CMp4EncAudioByteStream(<span class="keyword">this</span>, aq[ix].track_id, IVLength);
00333       } <span class="keywordflow">else</span> {
00334         abyte = <span class="keyword">new</span> CMp4AudioByteStream(<span class="keyword">this</span>, aq[ix].track_id);
00335       }
00336       MP4SetVerbosity(m_mp4file, verb);
00337 <span class="preprocessor">#else</span>
00338 <span class="preprocessor"></span>      tbyte = <span class="keyword">new</span> CMp4TextByteStream(<span class="keyword">this</span>, tq[ix].track_id);
00339 <span class="preprocessor">#endif</span>
00340 <span class="preprocessor"></span>
00341       <span class="keywordtype">int</span> ret;
00342       plugin = check_for_text_codec(tq[ix].stream_type,
00343                                     tq[ix].compressor,
00344                                     NULL,
00345                                     NULL,
00346                                     0, 
00347                                     &amp;config);
00348 
00349       ret = mptr-&gt;create_text_plugin(plugin,
00350                                      STREAM_TYPE_MP4_FILE,
00351                                      tq[ix].compressor,
00352                                      NULL, <span class="comment">// sdp info</span>
00353                                      NULL, 
00354                                      0);
00355       <span class="keywordflow">if</span> (ret &lt; 0) {
00356         mp4f_message(LOG_ERR, <span class="stringliteral">"Couldn't create text from plugin %s"</span>, 
00357                      plugin-&gt;c_name);
00358         psptr-&gt;set_message(<span class="stringliteral">"Couldn't start text plugin %s"</span>, 
00359                            plugin-&gt;c_name);
00360         <span class="keyword">delete</span> mptr;
00361         <span class="keyword">delete</span> tbyte;
00362         <span class="keywordflow">return</span> -1;
00363       }
00364 
00365       ret = mptr-&gt;create_media(<span class="stringliteral">"text"</span>, tbyte);
00366       <span class="keywordflow">if</span> (ret != 0) {
00367         <span class="keywordflow">return</span> (-1);
00368       }
00369       MP4SetVerbosity(m_mp4file, verb &amp; ~(MP4_DETAILS_ERROR));
00370       <span class="keywordtype">char</span> *mp4info = MP4Info(m_mp4file, tq[ix].track_id);
00371       MP4SetVerbosity(m_mp4file, verb);
00372       <span class="keywordtype">char</span> *temp = mp4info;
00373       <span class="keywordflow">while</span> (*temp != <span class="charliteral">'\0'</span>) {
00374         <span class="keywordflow">if</span> (isspace(*temp)) *temp = <span class="charliteral">' '</span>;
00375         <span class="keywordflow">if</span> (!isprint(*temp)) *temp = <span class="charliteral">'*'</span>;
00376         temp++;
00377       }
00378       psptr-&gt;set_session_desc(start_desc, mp4info);
00379       free(mp4info);
00380       start_desc++;
00381     } <span class="keywordflow">else</span> {
00382       CHECK_AND_FREE(tq[ix].config);
00383     }
00384   }
00385 
00386   <span class="keywordflow">return</span> 0;
00387 }
00388 
00389 
00390 <span class="keywordtype">int</span> CMp4File::create_media (CPlayerSession *psptr,
00391                             <span class="keywordtype">int</span> have_audio_driver,
00392                             control_callback_vft_t *cc_vft)
00393 {
00394   uint video_count, video_offset;
00395   uint text_count, text_offset;
00396   uint audio_count, audio_offset;
00397   MP4TrackId trackId;
00398   video_query_t *vq;
00399   audio_query_t *aq;
00400   text_query_t *tq;
00401   uint ix;
00402   codec_plugin_t *plugin;
00403   <span class="keywordtype">int</span> ret_value = 0;
00404   uint8_t *foo;
00405   u_int32_t bufsize;
00406   
00407   uint32_t verb = MP4GetVerbosity(m_mp4file);
00408   MP4SetVerbosity(m_mp4file, verb &amp; ~(MP4_DETAILS_ERROR));
00409   video_count = MP4GetNumberOfTracks(m_mp4file, MP4_VIDEO_TRACK_TYPE);
00410   audio_count = MP4GetNumberOfTracks(m_mp4file, MP4_AUDIO_TRACK_TYPE);
00411   text_count = MP4GetNumberOfTracks(m_mp4file, MP4_CNTL_TRACK_TYPE);
00412   mp4f_message(LOG_DEBUG, <span class="stringliteral">"cntl tracks %u"</span>, text_count);
00413   MP4SetVerbosity(m_mp4file, verb);
00414 
00415   <span class="keywordflow">if</span> (video_count == 0 &amp;&amp; audio_count == 0 &amp;&amp; text_count == 0) {
00416     psptr-&gt;set_message(<span class="stringliteral">"No audio, video or control tracks in file"</span>);
00417     <span class="keywordflow">return</span> -1;
00418   }
00419 
00420   <span class="keywordflow">if</span> (video_count &gt; 0) {
00421     vq = (video_query_t *)malloc(<span class="keyword">sizeof</span>(video_query_t) * video_count);
00422     memset(vq, 0, <span class="keyword">sizeof</span>(video_query_t) * video_count);
00423   } <span class="keywordflow">else</span> {
00424     vq = NULL;
00425   }
00426   <span class="keywordflow">if</span> (have_audio_driver &amp;&amp; audio_count &gt; 0) {
00427     aq = (audio_query_t *)malloc(<span class="keyword">sizeof</span>(audio_query_t) * audio_count);
00428     memset(aq, 0, <span class="keyword">sizeof</span>(audio_query_t) * audio_count);
00429   } <span class="keywordflow">else</span> {
00430     aq = NULL;
00431   }
00432 
00433   <span class="keywordflow">if</span> (text_count &gt; 0) {
00434     tq = (text_query_t *)malloc(<span class="keyword">sizeof</span>(text_query_t) * text_count);
00435     memset(tq, 0, <span class="keyword">sizeof</span>(text_query_t) * text_count);
00436   } <span class="keywordflow">else</span> {
00437     tq = NULL;
00438   }
00439   <span class="keywordflow">for</span> (ix = 0, video_offset = 0; ix &lt; video_count; ix++) {
00440     trackId = MP4FindTrackId(m_mp4file, ix, MP4_VIDEO_TRACK_TYPE);
00441     <span class="keyword">const</span> <span class="keywordtype">char</span> *media_data_name;
00442     media_data_name = MP4GetTrackMediaDataName(m_mp4file, trackId);
00443     <span class="comment">// for now, treat mp4v and encv the same</span>
00444     vq[video_offset].track_id = trackId;
00445     vq[video_offset].stream_type = STREAM_TYPE_MP4_FILE;
00446     vq[video_offset].compressor = media_data_name;
00447     <span class="keywordflow">if</span> (strcasecmp(media_data_name, <span class="stringliteral">"mp4v"</span>) == 0 ||
00448         strcasecmp(media_data_name, <span class="stringliteral">"encv"</span>) == 0) {
00449       uint8_t video_type = MP4GetTrackEsdsObjectTypeId(m_mp4file, trackId);
00450       uint8_t profileID = MP4GetVideoProfileLevel(m_mp4file, trackId);
00451       mp4f_message(LOG_DEBUG, <span class="stringliteral">"MP4 - got track %x profile ID %d"</span>, 
00452                  trackId, profileID);
00453       MP4SetVerbosity(m_mp4file, verb &amp; ~(MP4_DETAILS_ERROR));
00454       MP4GetTrackESConfiguration(m_mp4file, trackId, &amp;foo, &amp;bufsize);
00455       MP4SetVerbosity(m_mp4file, verb);
00456       vq[video_offset].type = video_type;
00457       vq[video_offset].profile = profileID;
00458       vq[video_offset].fptr = NULL;
00459       vq[video_offset].config = foo;
00460       vq[video_offset].config_len = bufsize;
00461     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcasecmp(media_data_name, <span class="stringliteral">"avc1"</span>) == 0) {
00462       uint8_t profile, level;
00463       uint8_t **seqheader, **pictheader;
00464       uint32_t *pictheadersize, *seqheadersize;
00465       uint32_t ix;
00466       MP4GetTrackH264ProfileLevel(m_mp4file, trackId, &amp;profile, &amp;level);
00467       MP4GetTrackH264SeqPictHeaders(m_mp4file, trackId, 
00468                                     &amp;seqheader, &amp;seqheadersize,
00469                                     &amp;pictheader, &amp;pictheadersize);
00470       bufsize = 0;
00471       <span class="keywordflow">for</span> (ix = 0; seqheadersize[ix] != 0; ix++) {
00472         bufsize += seqheadersize[ix] + 4;
00473       }
00474       <span class="keywordflow">for</span> (ix = 0; pictheadersize[ix] != 0; ix++) {
00475         bufsize += pictheadersize[ix] + 4;
00476       }
00477       foo = (uint8_t *)malloc(bufsize + 4);
00478       memset(foo, 0, bufsize + 4);
00479       uint32_t copied = 0;
00480       <span class="comment">// headers do not have the byte stream start code stored in the file</span>
00481       <span class="keywordflow">for</span> (ix = 0; seqheadersize[ix] != 0; ix++) {
00482         foo[copied] = 0;
00483         foo[copied + 1] = 0;
00484         foo[copied + 2] = 0;
00485         foo[copied + 3] = 1;
00486         copied += 4; <span class="comment">// add header</span>
00487         memcpy(foo + copied, 
00488                seqheader[ix], 
00489                seqheadersize[ix]);
00490         copied += seqheadersize[ix];
00491         free(seqheader[ix]);
00492       }
00493       free(seqheader);
00494       free(seqheadersize);
00495       <span class="keywordflow">for</span> (ix = 0; pictheadersize[ix] != 0; ix++) {
00496         foo[copied] = 0;
00497         foo[copied + 1] = 0;
00498         foo[copied + 2] = 0;
00499         foo[copied + 3] = 1;
00500         copied += 4; <span class="comment">// add header</span>
00501         memcpy(foo + copied, 
00502                pictheader[ix], 
00503                pictheadersize[ix]);
00504         copied += pictheadersize[ix];
00505         free(pictheader[ix]);
00506       }
00507       free(pictheader);
00508       free(pictheadersize);
00509         
00510       vq[video_offset].type = level;
00511       vq[video_offset].profile = profile;
00512       vq[video_offset].fptr = NULL;
00513       vq[video_offset].config = foo;
00514       vq[video_offset].config_len = bufsize;
00515     } <span class="keywordflow">else</span> {
00516       MP4GetTrackVideoMetadata(m_mp4file, trackId, &amp;foo, &amp;bufsize);
00517       vq[video_offset].config = foo;
00518       vq[video_offset].config_len = bufsize;
00519     }
00520 
00521       
00522     plugin = check_for_video_codec(vq[video_offset].stream_type,
00523                                    vq[video_offset].compressor,
00524                                    NULL,
00525                                    vq[video_offset].type,
00526                                    vq[video_offset].profile,
00527                                    vq[video_offset].config,
00528                                    vq[video_offset].config_len,
00529                                    &amp;config);
00530     <span class="keywordflow">if</span> (plugin == NULL) {
00531       psptr-&gt;set_message(<span class="stringliteral">"Can't find plugin for video %s type %d, profile %d"</span>,
00532                          vq[video_offset].compressor,
00533                          vq[video_offset].type, 
00534                          vq[video_offset].profile);
00535       m_illegal_video_codec++;
00536       ret_value = 1;
00537       <span class="comment">// possibly memleak for foo here</span>
00538     } <span class="keywordflow">else</span> {
00539       vq[video_offset].h = MP4GetTrackVideoHeight(m_mp4file, trackId);
00540       vq[video_offset].w = MP4GetTrackVideoWidth(m_mp4file, trackId);
00541       vq[video_offset].frame_rate = MP4GetTrackVideoFrameRate(m_mp4file, trackId);
00542       vq[video_offset].enabled = 0;
00543       vq[video_offset].reference = NULL;
00544       video_offset++;
00545     }
00546   }
00547 
00548   audio_offset = 0;
00549   <span class="keywordflow">if</span> (have_audio_driver) {
00550     <span class="keywordflow">for</span> (ix = 0; ix &lt; audio_count; ix++) {
00551       trackId = MP4FindTrackId(m_mp4file, ix, MP4_AUDIO_TRACK_TYPE);
00552       <span class="keyword">const</span> <span class="keywordtype">char</span> *media_data_name;
00553       media_data_name = MP4GetTrackMediaDataName(m_mp4file, trackId);
00554 
00555       aq[audio_offset].track_id = trackId;
00556       aq[audio_offset].stream_type = STREAM_TYPE_MP4_FILE;
00557       aq[audio_offset].compressor = media_data_name;
00558       <span class="keywordflow">if</span> (strcasecmp(media_data_name, <span class="stringliteral">"mp4a"</span>) == 0 ||
00559           strcasecmp(media_data_name, <span class="stringliteral">"enca"</span>) == 0) {
00560         uint8_t *userdata = NULL;
00561         u_int32_t userdata_size;
00562         aq[audio_offset].type = MP4GetTrackEsdsObjectTypeId(m_mp4file, trackId);
00563         MP4SetVerbosity(m_mp4file, verb &amp; ~(MP4_DETAILS_ERROR));
00564         aq[audio_offset].profile = MP4GetAudioProfileLevel(m_mp4file);
00565         MP4GetTrackESConfiguration(m_mp4file, 
00566                                    trackId, 
00567                                    &amp;userdata, 
00568                                    &amp;userdata_size);
00569         MP4SetVerbosity(m_mp4file, verb);
00570         aq[audio_offset].config = userdata;
00571         aq[audio_offset].config_len = userdata_size;
00572       }
00573       plugin = check_for_audio_codec(aq[audio_offset].stream_type,
00574                                      aq[audio_offset].compressor,
00575                                      NULL,
00576                                      aq[audio_offset].type,
00577                                      aq[audio_offset].profile,
00578                                      aq[audio_offset].config,
00579                                      aq[audio_offset].config_len,
00580                                      &amp;config);
00581       <span class="keywordflow">if</span> (plugin != NULL) {
00582         aq[audio_offset].fptr = NULL;
00583         aq[audio_offset].sampling_freq = 
00584           MP4GetTrackTimeScale(m_mp4file, trackId);
00585         MP4SetVerbosity(m_mp4file, verb &amp; ~(MP4_DETAILS_ERROR));
00586         aq[audio_offset].chans = MP4GetTrackAudioChannels(m_mp4file, trackId);
00587         MP4SetVerbosity(m_mp4file, verb);
00588         aq[audio_offset].enabled = 0;
00589         aq[audio_offset].reference = NULL;
00590         audio_offset++;
00591         m_have_audio = <span class="keyword">true</span>;
00592       } <span class="keywordflow">else</span> {
00593         m_illegal_audio_codec++;
00594         ret_value = 1;
00595       }
00596     }
00597   } <span class="keywordflow">else</span> {
00598     <span class="keywordflow">if</span> (audio_count)
00599       ret_value = 1;
00600   }
00601   text_offset = 0;
00602   <span class="keywordflow">for</span> (ix = 0; ix &lt; text_count; ix++) {
00603     trackId = MP4FindTrackId(m_mp4file, ix, MP4_CNTL_TRACK_TYPE);
00604     <span class="keyword">const</span> <span class="keywordtype">char</span> *media_data_name;
00605     media_data_name = MP4GetTrackMediaDataName(m_mp4file, trackId);
00606 
00607     tq[text_offset].track_id = trackId;
00608     tq[text_offset].stream_type = STREAM_TYPE_MP4_FILE;
00609     tq[text_offset].compressor = media_data_name;
00610     plugin = check_for_text_codec(tq[text_offset].stream_type,
00611                                   tq[text_offset].compressor,
00612                                   NULL,
00613                                   NULL,
00614                                   0, 
00615                                   &amp;config);
00616     <span class="keywordflow">if</span> (plugin != NULL) {
00617       tq[text_offset].fptr = NULL;
00618       tq[text_offset].enabled = 0;
00619       tq[text_offset].reference = NULL;
00620       text_offset++;
00621     } <span class="keywordflow">else</span> {
00622       m_illegal_text_codec++;
00623       ret_value = 1;
00624     }
00625   }
00626 
00627   <span class="keywordflow">if</span> (video_offset == 0 &amp;&amp; audio_offset == 0 &amp;&amp; text_offset == 0) {
00628     psptr-&gt;set_message(<span class="stringliteral">"No playable codecs in mp4 file"</span>);
00629     <span class="keywordflow">return</span> -1;
00630   }
00631   <span class="keywordflow">if</span> (cc_vft &amp;&amp; cc_vft-&gt;media_list_query != NULL) {
00632     (cc_vft-&gt;media_list_query)(psptr, video_offset, vq, audio_offset, aq, text_offset, tq);
00633   } <span class="keywordflow">else</span> {
00634     <span class="keywordflow">if</span> (video_offset &gt; 0) {
00635       vq[0].enabled = 1;
00636     }
00637     <span class="keywordflow">if</span> (audio_offset &gt; 0) {
00638       aq[0].enabled = 1;
00639     }
00640     <span class="keywordflow">if</span> (text_offset &gt; 0) {
00641       tq[0].enabled = 1;
00642     }
00643   }
00644 
00645   <span class="keywordtype">int</span> vidret, audret, textret;
00646   uint start_desc = 1;
00647   vidret = create_video(psptr, vq, video_offset, start_desc);
00648   free(vq);
00649 
00650   <span class="keywordflow">if</span> (vidret &lt; 0) {
00651     free(aq);
00652     free(tq);
00653     <span class="keywordflow">return</span> -1;
00654   }
00655  
00656   audret = create_audio(psptr, aq, audio_offset, start_desc);
00657   free(aq);
00658 
00659   textret = create_text(psptr, tq, text_offset, start_desc);
00660   free(tq);
00661 
00662   <span class="keywordflow">if</span> (audret &lt; 0 || textret &lt; 0) ret_value = -1;
00663 
00664   <span class="keywordtype">char</span> *name;
00665   verb = MP4GetVerbosity(m_mp4file);
00666   MP4SetVerbosity(m_mp4file, verb &amp; ~(MP4_DETAILS_ERROR));
00667   <span class="keywordflow">if</span> (MP4GetMetadataName(m_mp4file, &amp;name) &amp;&amp;
00668       name != NULL) {
00669     psptr-&gt;set_session_desc(0, name);
00670     free(name);
00671   }
00672   MP4SetVerbosity(m_mp4file, verb);
00673   
00674   <span class="keywordflow">return</span> (ret_value);
00675 }
00676 
00677 <span class="comment">/* end file mp4_file.cpp */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sat Jun 10 19:20:59 2006 for "MPEG4IP with DRM support" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
