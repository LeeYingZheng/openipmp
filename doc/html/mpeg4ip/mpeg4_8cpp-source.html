<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>&quot;MPEG4IP with DRM support&quot;: mpeg4.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>mpeg4.cpp</h1><a href="mpeg4_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00006 <span class="comment">/*</span>
00007 <span class="comment"> * The contents of this file are subject to the Mozilla Public</span>
00008 <span class="comment"> * License Version 1.1 (the "License"); you may not use this file</span>
00009 <span class="comment"> * except in compliance with the License. You may obtain a copy of</span>
00010 <span class="comment"> * the License at http://www.mozilla.org/MPL/</span>
00011 <span class="comment"> * </span>
00012 <span class="comment"> * Software distributed under the License is distributed on an "AS</span>
00013 <span class="comment"> * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or</span>
00014 <span class="comment"> * implied. See the License for the specific language governing</span>
00015 <span class="comment"> * rights and limitations under the License.</span>
00016 <span class="comment"> * </span>
00017 <span class="comment"> * The Original Code is MPEG4IP.</span>
00018 <span class="comment"> * </span>
00019 <span class="comment"> * The Initial Developer of the Original Code is Cisco Systems Inc.</span>
00020 <span class="comment"> * Portions created by Cisco Systems Inc. are</span>
00021 <span class="comment"> * Copyright (C) Cisco Systems Inc. 2000, 2001.  All Rights Reserved.</span>
00022 <span class="comment"> * </span>
00023 <span class="comment"> * Contributor(s): </span>
00024 <span class="comment"> *              Bill May        wmay@cisco.com</span>
00025 <span class="comment"> */</span>
00026 <span class="comment">/*</span>
00027 <span class="comment"> * mpeg4.cpp - implementation with ISO reference codec</span>
00028 <span class="comment"> */</span>
00029 
00030 
00031 <span class="preprocessor">#define DECLARE_CONFIG_VARIABLES</span>
00032 <span class="preprocessor"></span><span class="preprocessor">#include "codec_plugin.h"</span>
00033 
00034 <span class="comment">//  BEGIN  Added for DRM support.</span>
00035 <span class="comment">//  Include DRM headers.</span>
00036 <span class="preprocessor">#include "IXMLDocument.h"</span>
00037 <span class="preprocessor">#include "DecryptorHolder.h"</span>
00038 <span class="preprocessor">#include "IMPEG4DRMAtom.h"</span>
00039 <span class="preprocessor">#include "<a class="code" href="drm__plugin__data_8h.html">drm_plugin_data.h</a>"</span>
00040 <span class="keyword">using</span> <span class="keyword">namespace </span>DRMPlugin;
00041 <span class="comment">//  END    Added for DRM support.</span>
00042 
00043 <span class="preprocessor">#if 0</span>
00044 <span class="preprocessor"></span><span class="preprocessor">#ifdef _WIN32</span>
00045 <span class="preprocessor"></span><span class="preprocessor">#include &lt;windows.h&gt;</span>
00046 <span class="preprocessor">#include &lt;mmsystem.h&gt;</span>
00047 <span class="preprocessor">#endif // __PC_COMPILER_</span>
00048 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00049 <span class="preprocessor"></span>
00050 <span class="preprocessor">#include &lt;typeapi.h&gt;</span>
00051 <span class="preprocessor">#include &lt;mode.hpp&gt;</span>
00052 <span class="preprocessor">#include &lt;vopses.hpp&gt;</span>
00053 <span class="preprocessor">#include &lt;bitstrm.hpp&gt;</span>
00054 <span class="preprocessor">#include &lt;tps_enhcbuf.hpp&gt;</span>
00055 <span class="preprocessor">#include &lt;enhcbufdec.hpp&gt;</span>
00056 <span class="preprocessor">#include &lt;vopsedec.hpp&gt;</span>
00057 <span class="preprocessor">#include "<a class="code" href="mmpeg4_8h.html">mmpeg4.h</a>"</span>
00058 
00059 <span class="preprocessor">#include &lt;mp4v2/mp4.h&gt;</span>
00060 <span class="preprocessor">#include &lt;mp4av/mp4av.h&gt;</span>
00061 
00062 <span class="preprocessor">#define iso_message (iso-&gt;m_vft-&gt;log_msg)</span>
00063 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *mp4iso = <span class="stringliteral">"mp4iso"</span>;
00064 <span class="keyword">static</span> SConfigVariable MyConfigVariables[] = {
00065   CONFIG_BOOL(CONFIG_USE_MPEG4_ISO_ONLY, <span class="stringliteral">"Mpeg4IsoOnly"</span>, <span class="keyword">false</span>),
00066 };
00067 
00068 <span class="comment">// Convert a hex character to it's decimal value.</span>
00069 <span class="keyword">static</span> uint8_t tohex (<span class="keywordtype">char</span> a)
00070 { 
00071   <span class="keywordflow">if</span> (isdigit(a))
00072     <span class="keywordflow">return</span> (a - <span class="charliteral">'0'</span>);
00073   <span class="keywordflow">return</span> (tolower(a) - <span class="charliteral">'a'</span> + 10);
00074 }
00075 
00076 <span class="keyword">static</span> <span class="keywordtype">double</span> calculate_aspect_ratio (<a class="code" href="structiso__decode__t.html">iso_decode_t</a> *iso)
00077 {
00078   <span class="keywordtype">double</span> ret_val;
00079   <span class="keywordtype">int</span> aspect_ratio_h;
00080   <span class="keywordtype">int</span> aspect_ratio_w;
00081 
00082   ret_val = 0.0;
00083   aspect_ratio_h = 0;
00084   aspect_ratio_w = 0;
00085   <span class="keywordflow">switch</span> (iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;getvolAspectRatio()) {
00086   <span class="keywordflow">default</span>:
00087     <span class="keywordflow">break</span>; 
00088   <span class="keywordflow">case</span> 2:
00089     aspect_ratio_w = 12;
00090     aspect_ratio_h = 11;
00091     <span class="keywordflow">break</span>;
00092   <span class="keywordflow">case</span> 3:
00093     aspect_ratio_w = 10;
00094     aspect_ratio_h = 11;
00095     <span class="keywordflow">break</span>;
00096   <span class="keywordflow">case</span> 4:
00097     aspect_ratio_w = 16;
00098     aspect_ratio_h = 11;
00099     <span class="keywordflow">break</span>;
00100   <span class="keywordflow">case</span> 5:
00101     aspect_ratio_w = 40;
00102     aspect_ratio_h = 33;
00103     <span class="keywordflow">break</span>;
00104   <span class="keywordflow">case</span> 0xf:
00105     aspect_ratio_w = iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;getvolAspectWidth();
00106     aspect_ratio_h = iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;getvolAspectHeight();
00107     <span class="keywordflow">break</span>;
00108   }
00109 
00110   <span class="keywordflow">if</span> (aspect_ratio_h != 0) {
00111     ret_val = (double)iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;getvolWidth();
00112     ret_val *= (double)aspect_ratio_w;
00113     ret_val /= (double)iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;getvolHeight();
00114     ret_val /= (double)aspect_ratio_h;
00115   }
00116   <span class="keywordflow">return</span> ret_val;
00117 }
00118 
00119 <span class="comment">// Parse the format config passed in.  This is the vo vod header</span>
00120 <span class="comment">// that we need to get width/height/frame rate</span>
00121 <span class="keyword">static</span> <span class="keywordtype">int</span> parse_vovod (<a class="code" href="structiso__decode__t.html">iso_decode_t</a> *iso,
00122                         <span class="keyword">const</span> <span class="keywordtype">char</span> *vovod,
00123                         <span class="keywordtype">int</span> ascii,
00124                         uint32_t len)
00125 {
00126   uint8_t buffer[255];
00127   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *bufptr;
00128 
00129   <span class="keywordflow">if</span> (ascii == 1) {
00130     <span class="keyword">const</span> <span class="keywordtype">char</span> *config = strcasestr(vovod, <span class="stringliteral">"config="</span>);
00131     <span class="keywordflow">if</span> (config == NULL) {
00132       <span class="keywordflow">return</span> 0;
00133     }
00134     config += strlen(<span class="stringliteral">"config="</span>);
00135     <span class="keyword">const</span> <span class="keywordtype">char</span> *end;
00136     end = config;
00137     <span class="keywordflow">while</span> (isxdigit(*end)) end++;
00138     <span class="keywordflow">if</span> (config == end) {
00139       <span class="keywordflow">return</span> 0;
00140     }
00141     <span class="comment">// config string will run from config to end</span>
00142     len = end - config;
00143     <span class="comment">// make sure we have even number of digits to convert to binary</span>
00144     <span class="keywordflow">if</span> ((len % 2) == 1) 
00145       <span class="keywordflow">return</span> 0;
00146     uint8_t *write;
00147     write = buffer;
00148     <span class="comment">// Convert the config= from ascii to binary</span>
00149     <span class="keywordflow">for</span> (uint32_t ix = 0; ix &lt; len; ix++) {
00150       *write = 0;
00151       *write = (tohex(*config)) &lt;&lt; 4;
00152       config++;
00153       *write += tohex(*config);
00154       config++;
00155       write++;
00156     }
00157     len /= 2;
00158     bufptr = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)&amp;buffer[0];
00159   } <span class="keywordflow">else</span> {
00160     bufptr = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)vovod;
00161   }
00162 
00163 <span class="preprocessor">#if 0</span>
00164 <span class="preprocessor"></span>  <span class="keywordflow">for</span> (uint32_t jx = 0; jx &lt; len; jx++) {
00165     printf(<span class="stringliteral">"%02x "</span>, bufptr[jx]);
00166   }
00167   printf(<span class="stringliteral">"\n"</span>);
00168 <span class="preprocessor">#endif</span>
00169 <span class="preprocessor"></span>  
00170   <span class="comment">// Create a byte stream to take from our buffer.</span>
00171   <span class="comment">// Temporary set of our bytestream</span>
00172   <span class="comment">// Get the VOL header.  If we fail, set the bytestream back</span>
00173   <span class="keywordtype">int</span> havevol = 0;
00174   <span class="keywordflow">do</span> {
00175     <span class="keywordflow">try</span> {
00176       iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;SetUpBitstreamBuffer(bufptr, len);
00177       iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;decodeVOLHead();
00178       iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;postVO_VOLHeadInit(iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;getWidth(),
00179                                    iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;getHeight(),
00180                                    &amp;iso-&gt;<a class="code" href="structiso__decode__t.html#o5">m_bSpatialScalability</a>);
00181       iso_message(LOG_DEBUG, mp4iso, <span class="stringliteral">"Found VOL in header"</span>);
00182       <span class="keywordflow">if</span> (iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;fSptUsage() == 2) {
00183         iso_message(LOG_INFO, mp4iso, <span class="stringliteral">"Warning: GMC detected - this reference code does not decode GMC properly - artifacts may occur"</span>);
00184       }
00185       iso-&gt;m_vft-&gt;video_configure(iso-&gt;m_ifptr, 
00186                                   iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;getWidth(),
00187                                   iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;getHeight(),
00188                                   VIDEO_FORMAT_YUV,
00189                                   calculate_aspect_ratio(iso));
00190       havevol = 1;
00191     } <span class="keywordflow">catch</span> (<span class="keywordtype">int</span> err) {
00192       iso_message(LOG_DEBUG, mp4iso, 
00193                   <span class="stringliteral">"Caught exception in VOL mem header search"</span>);
00194       <span class="keywordflow">if</span> (err == 1519) {
00195         iso_message(LOG_DEBUG, mp4iso, 
00196                     <span class="stringliteral">"Error decoding VOL - video may not play correctly"</span>);
00197       }
00198     }
00199     uint32_t used;
00200     used = iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;get_used_bytes();
00201     <span class="keywordflow">if</span> (used == 0) used += 4;
00202     bufptr += used;
00203     <span class="keywordflow">if</span> (len &gt; used) len -= used;
00204     <span class="keywordflow">else</span> len = 0;
00205   } <span class="keywordflow">while</span> (havevol == 0 &amp;&amp; len &gt; 0);
00206 
00207 
00208   <span class="comment">// We've found the VO VOL header - that's good.</span>
00209   <span class="comment">// Reset the byte stream back to what it was, delete our temp stream</span>
00210   <span class="comment">//player_debug_message("Decoded vovod header correctly");</span>
00211   <span class="keywordflow">return</span> havevol;
00212 }
00213 
00214 <span class="keyword">static</span> codec_data_t *iso_create (<span class="keyword">const</span> <span class="keywordtype">char</span> *stream_type,
00215                                  <span class="keyword">const</span> <span class="keywordtype">char</span> *compressor, 
00216                                  <span class="keywordtype">int</span> type, 
00217                                  <span class="keywordtype">int</span> profile, 
00218                                  format_list_t *media_fmt,
00219                                  video_info_t *vinfo,
00220                                  <span class="keyword">const</span> uint8_t *userdata,
00221                                  uint32_t ud_size,
00222                                  video_vft_t *vft,
00223                                  <span class="keywordtype">void</span> *ifptr)
00224 {
00225   <a class="code" href="structiso__decode__t.html">iso_decode_t</a> *iso;
00226 
00227   iso = MALLOC_STRUCTURE(<a class="code" href="structiso__decode__t.html">iso_decode_t</a>);
00228   <span class="keywordflow">if</span> (iso == NULL) <span class="keywordflow">return</span> NULL;
00229   memset(iso, 0, <span class="keyword">sizeof</span>(*iso));
00230   iso-&gt;m_vft = vft;
00231   iso-&gt;m_ifptr = ifptr;
00232 
00233   iso-&gt;m_main_short_video_header = FALSE;
00234   iso-&gt;m_pvodec = <span class="keyword">new</span> CVideoObjectDecoder();
00235   iso-&gt;m_decodeState = DECODE_STATE_VOL_SEARCH;
00236   <span class="keywordflow">if</span> (media_fmt != NULL &amp;&amp; media_fmt-&gt;fmt_param != NULL) {
00237     <span class="comment">// See if we can decode a passed in vovod header</span>
00238     <span class="keywordflow">if</span> (parse_vovod(iso, media_fmt-&gt;fmt_param, 1, 0) == 1) {
00239       iso-&gt;m_decodeState = DECODE_STATE_WAIT_I;
00240     }
00241   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (userdata != NULL) {
00242     <span class="keywordflow">if</span> (parse_vovod(iso, (<span class="keyword">const</span> <span class="keywordtype">char</span> *)userdata, 0, ud_size) == 1) {
00243       iso-&gt;m_decodeState = DECODE_STATE_WAIT_I;
00244     }
00245   }
00246   iso-&gt;m_vinfo = vinfo;
00247 
00248   iso-&gt;m_num_wait_i = 0;
00249   iso-&gt;m_num_wait_i_frames = 0;
00250   iso-&gt;m_total_frames = 0;
00251 
00252   <span class="comment">//  BEGIN  Added for DRM support.</span>
00253   <span class="comment">//  Save content 4CC code, to recognize protected content when decoding.</span>
00254   iso-&gt;compressor = compressor;
00255   <span class="comment">//  END    Added for DRM support.</span>
00256 
00257   <span class="keywordflow">return</span> (codec_data_t *)iso;
00258 }
00259 
00260 <span class="keywordtype">void</span> iso_clean_up (<a class="code" href="structiso__decode__t.html">iso_decode_t</a> *iso)
00261 {
00262   <span class="keywordflow">if</span> (iso-&gt;m_ifile != NULL) {
00263     fclose(iso-&gt;m_ifile);
00264     iso-&gt;m_ifile = NULL;
00265   }
00266   <span class="keywordflow">if</span> (iso-&gt;m_buffer != NULL) {
00267     free(iso-&gt;m_buffer);
00268     iso-&gt;m_buffer = NULL;
00269   }
00270   <span class="keywordflow">if</span> (iso-&gt;m_fpos != NULL) {
00271     <span class="keyword">delete</span> iso-&gt;m_fpos;
00272     iso-&gt;m_fpos = NULL;
00273   }
00274   
00275   <span class="keywordflow">if</span> (iso-&gt;m_pvodec) {
00276     <span class="keyword">delete</span> iso-&gt;m_pvodec;
00277     iso-&gt;m_pvodec = NULL;
00278   }
00279 
00280   free(iso);
00281 }
00282 
00283 <span class="keyword">static</span> <span class="keywordtype">void</span> iso_close (codec_data_t *ptr)
00284 {
00285   <a class="code" href="structiso__decode__t.html">iso_decode_t</a> *iso = (<a class="code" href="structiso__decode__t.html">iso_decode_t</a> *)ptr;
00286 
00287   iso_message(LOG_INFO, mp4iso, <span class="stringliteral">"MPEG4 codec results:"</span>);
00288   iso_message(LOG_INFO, mp4iso,
00289               <span class="stringliteral">"total frames    : %u"</span>, iso-&gt;<a class="code" href="structiso__decode__t.html#o15">m_total_frames</a>);
00290   iso_message(LOG_INFO, mp4iso,
00291               <span class="stringliteral">"wait for I times: %u"</span>, iso-&gt;<a class="code" href="structiso__decode__t.html#o13">m_num_wait_i</a>);
00292   iso_message(LOG_INFO, mp4iso,
00293               <span class="stringliteral">"wait I frames   : %u"</span>, iso-&gt;<a class="code" href="structiso__decode__t.html#o14">m_num_wait_i_frames</a>);
00294 
00295   iso_clean_up(iso);
00296 }
00297 
00298 
00299 <span class="keyword">static</span> <span class="keywordtype">void</span> iso_do_pause (codec_data_t *ptr)
00300 {
00301   <a class="code" href="structiso__decode__t.html">iso_decode_t</a> *iso = (<a class="code" href="structiso__decode__t.html">iso_decode_t</a> *)ptr;
00302   <span class="keywordflow">if</span> (iso-&gt;<a class="code" href="structiso__decode__t.html#o4">m_decodeState</a> != DECODE_STATE_VOL_SEARCH)
00303     iso-&gt;<a class="code" href="structiso__decode__t.html#o4">m_decodeState</a> = DECODE_STATE_WAIT_I;
00304 }
00305 <span class="keyword">static</span> <span class="keywordtype">int</span> iso_frame_is_sync (codec_data_t *ptr,
00306                               uint8_t *buffer, 
00307                               uint32_t buflen,
00308                               <span class="keywordtype">void</span> *userdata)
00309 {
00310   u_char vop_type;
00311 
00312   <span class="keywordflow">while</span> (buflen &gt; 3 &amp;&amp; 
00313          !(buffer[0] == 0 &amp;&amp; buffer[1] == 0 &amp;&amp; 
00314            buffer[2] == 1 &amp;&amp; buffer[3] == MP4AV_MPEG4_VOP_START)) {
00315     buffer++;
00316     buflen--;
00317   }
00318 
00319   vop_type = MP4AV_Mpeg4GetVopType(buffer, buflen);
00320 <span class="preprocessor">#if 0</span>
00321 <span class="preprocessor"></span>  {
00322   <a class="code" href="structiso__decode__t.html">iso_decode_t</a> *iso = (<a class="code" href="structiso__decode__t.html">iso_decode_t</a> *)ptr;
00323   iso_message(LOG_DEBUG, <span class="stringliteral">"iso"</span>, <span class="stringliteral">"return from get vop is %c %d"</span>, vop_type, vop_type);
00324   }
00325 <span class="preprocessor">#endif</span>
00326 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (vop_type == VOP_TYPE_I) <span class="keywordflow">return</span> 1;
00327   <span class="keywordflow">return</span> 0;
00328 }
00329 
<a name="l00332"></a><a class="code" href="mpeg4_8cpp.html#a13">00332</a> <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="mpeg4_8cpp.html#a13">iso_decode</a> (codec_data_t *ptr, 
00333                        frame_timestamp_t *ts, 
00334                        <span class="keywordtype">int</span> from_rtp, 
00335                        <span class="keywordtype">int</span> *sync_frame,
00336                        uint8_t *buffer,
00337                        uint32_t buflen,
00338                        <span class="keywordtype">void</span> *userdata)
00339 {
00340   Int iEof = 1;
00341   <a class="code" href="structiso__decode__t.html">iso_decode_t</a> *iso = (<a class="code" href="structiso__decode__t.html">iso_decode_t</a> *)ptr;
00342   uint32_t used = 0;
00343 
00344   <span class="comment">//  BEGIN  Added for DRM support.</span>
00345   <span class="comment">//  If we need to perform decryption, this buffer will be used for it.</span>
00346   uint8_t *dBuffer = 0;
00347   uint32_t dBuflen;
00348 
00349   <span class="comment">//  Check if content is protected, by inspecting its 4CC code. If it is,</span>
00350   <span class="comment">//  and bytestream reader passed DRM data, take out DRM data and use</span>
00351   <span class="comment">//  DecryptorHolder to get decryptor. If GetDecryptor() routine returns</span>
00352   <span class="comment">//  false, it means that some error happened. If GetDecryptor() returns true,</span>
00353   <span class="comment">//  and returned decryptor is 0, it means that no decryption needs to be done.</span>
00354   <span class="comment">//  If GetDecryptor() returns true, and decryptor is != 0, it means that we</span>
00355   <span class="comment">//  need to decrypt sample.</span>
00356   <span class="keywordflow">if</span> ((strcmp(iso-&gt;<a class="code" href="structiso__decode__t.html#o27">compressor</a>, <span class="stringliteral">"encv"</span>) == 0) &amp;&amp; (userdata != 0)) {
00357     <a class="code" href="structdrm__plugin__data__t.html">drm_plugin_data_t</a>* drm_data = (<a class="code" href="structdrm__plugin__data__t.html">drm_plugin_data_t</a>*)userdata;
00358     <span class="keywordflow">try</span> {
00359       DRMPlugin::IXMLElement* xml = drm_data-&gt;<a class="code" href="structdrm__plugin__data__t.html#o0">xml</a>;
00360       DRMLogger&amp; logger = *(drm_data-&gt;<a class="code" href="structdrm__plugin__data__t.html#o1">logger</a>);
00361       MPEG4SinfDRMPlugin::IMP4SinfAtom* sinf = drm_data-&gt;<a class="code" href="structdrm__plugin__data__t.html#o2">sinf</a>;
00362 
00363       free(userdata); userdata = 0;
00364 
00365       <span class="keyword">static</span> MPEG4SinfDRMPlugin::DecryptorHolder holder(xml, logger);
00366 
00367       <span class="keywordflow">if</span> (sinf != 0) {
00368         IDRMDecryptor* decryptor = 0;
00369         <span class="keywordflow">if</span> (holder.GetDecryptor(sinf, &amp;decryptor) == <span class="keyword">false</span>) {
00370           <span class="keywordflow">return</span> -1;
00371         }
00372         <span class="keywordflow">if</span> (decryptor != 0) {
00373           <span class="keywordflow">if</span> (decryptor-&gt;Decrypt((ByteT*)buffer, buflen, (ByteT**)&amp;dBuffer,
00374               &amp;dBuflen) == <span class="keyword">false</span>) {
00375             <span class="keywordflow">return</span> -1;
00376           }
00377 
00378           <span class="keywordflow">if</span> (dBuflen &lt;= 4) {
00379             <span class="keywordflow">if</span> (dBuffer != 0) free(dBuffer);
00380             <span class="keywordflow">return</span> -1;
00381           }
00382         }
00383 
00384         buffer = dBuffer;
00385         buflen = dBuflen;
00386       }
00387     }
00388     <span class="keywordflow">catch</span> (...) {
00389       <span class="keywordflow">return</span> -1;
00390     }
00391   }
00392   <span class="comment">//  END    Added for DRM support.</span>
00393 
00394   <span class="comment">//  iso_message(LOG_DEBUG, "iso", "frame %d", iso-&gt;m_total_frames);</span>
00395   iso-&gt;<a class="code" href="structiso__decode__t.html#o15">m_total_frames</a>++;
00396   buffer[buflen] = 0;
00397   buffer[buflen + 1] = 0;
00398   buffer[buflen + 2] = 1;
00399 
00400   <span class="keywordflow">switch</span> (iso-&gt;<a class="code" href="structiso__decode__t.html#o4">m_decodeState</a>) {
00401   <span class="keywordflow">case</span> DECODE_STATE_VOL_SEARCH: {
00402     <span class="keywordflow">if</span> (buffer[0] == 0 &amp;&amp;
00403         buffer[1] == 0 &amp;&amp;
00404         (buffer[2] &amp; 0xfc) == 0x80 &amp;&amp;
00405         (buffer[3] &amp; 0x03) == 0x02) {
00406       <span class="comment">// we have the short header</span>
00407       iso-&gt;<a class="code" href="structiso__decode__t.html#o26">m_short_header</a> = 1;
00408       iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;SetUpBitstreamBuffer((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)buffer, buflen);
00409       iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;video_plane_with_short_header();
00410       iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;postVO_VOLHeadInit(iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;getWidth(),
00411                                         iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;getHeight(),
00412                                         &amp;iso-&gt;<a class="code" href="structiso__decode__t.html#o5">m_bSpatialScalability</a>);
00413       iso_message(LOG_INFO, mp4iso, <span class="stringliteral">"Decoding using short headers"</span>);
00414       iso-&gt;m_vft-&gt;video_configure(iso-&gt;m_ifptr, 
00415                                   iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;getWidth(),
00416                                   iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;getHeight(),
00417                                   VIDEO_FORMAT_YUV,
00418                                   calculate_aspect_ratio(iso));
00419       iso-&gt;<a class="code" href="structiso__decode__t.html#o4">m_decodeState</a> = DECODE_STATE_NORMAL;
00420       <span class="keywordflow">try</span> {
00421         iEof = iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;h263_decode(FALSE);
00422       } <span class="keywordflow">catch</span> (...) {
00423         iso_message(LOG_ERR, mp4iso, <span class="stringliteral">"Couldn't decode h263 in vol search"</span>);
00424       }
00425       <span class="keywordflow">break</span>; 
00426     } <span class="keywordflow">else</span> {
00427       uint8_t *volhdr = MP4AV_Mpeg4FindVol(buffer, buflen);
00428       <span class="keywordflow">if</span> (volhdr != NULL) {
00429         used = volhdr - buffer;
00430         <span class="keywordflow">try</span> {
00431           iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;SetUpBitstreamBuffer((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)volhdr, buflen - used);
00432           iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;decodeVOLHead();
00433           iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;postVO_VOLHeadInit(iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;getWidth(),
00434                                             iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;getHeight(),
00435                                           &amp;iso-&gt;<a class="code" href="structiso__decode__t.html#o5">m_bSpatialScalability</a>);
00436           iso_message(LOG_INFO, mp4iso, <span class="stringliteral">"Found VOL"</span>);
00437         
00438           iso-&gt;m_vft-&gt;video_configure(iso-&gt;m_ifptr, 
00439                                       iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;getWidth(),
00440                                       iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;getHeight(),
00441                                       VIDEO_FORMAT_YUV,
00442                                       calculate_aspect_ratio(iso));
00443         
00444           iso-&gt;<a class="code" href="structiso__decode__t.html#o4">m_decodeState</a> = DECODE_STATE_WAIT_I;
00445           used += iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;get_used_bytes();
00446         } <span class="keywordflow">catch</span> (<span class="keywordtype">int</span> err) {
00447           iso_message(LOG_DEBUG, mp4iso, <span class="stringliteral">"Caught exception in VOL search %d"</span>, err);
00448           <span class="keywordflow">if</span> (err == 1) used = buflen;
00449           <span class="keywordflow">else</span> used += iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;get_used_bytes();
00450         }
00451       }
00452     }
00453     <span class="keywordflow">if</span> (iso-&gt;<a class="code" href="structiso__decode__t.html#o4">m_decodeState</a> != DECODE_STATE_WAIT_I) {
00454       <span class="keywordflow">if</span> (iso-&gt;<a class="code" href="structiso__decode__t.html#o25">m_vinfo</a> != NULL) {
00455         iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;FakeOutVOVOLHead(iso-&gt;<a class="code" href="structiso__decode__t.html#o25">m_vinfo</a>-&gt;height,
00456                                         iso-&gt;<a class="code" href="structiso__decode__t.html#o25">m_vinfo</a>-&gt;width,
00457                                         30,
00458                                         &amp;iso-&gt;<a class="code" href="structiso__decode__t.html#o5">m_bSpatialScalability</a>);
00459         iso-&gt;m_vft-&gt;video_configure(iso-&gt;m_ifptr, 
00460                                     iso-&gt;<a class="code" href="structiso__decode__t.html#o25">m_vinfo</a>-&gt;width,
00461                                     iso-&gt;<a class="code" href="structiso__decode__t.html#o25">m_vinfo</a>-&gt;height,
00462                                     VIDEO_FORMAT_YUV,
00463                                     calculate_aspect_ratio(iso));
00464 
00465         iso-&gt;<a class="code" href="structiso__decode__t.html#o4">m_decodeState</a> = DECODE_STATE_NORMAL;
00466       }
00467 
00468       <span class="comment">//  BEGIN  Added for DRM support.</span>
00469       <span class="comment">//  If we performed decryption, we need to free memory.</span>
00470       <span class="keywordflow">if</span> (dBuffer != 0) free(dBuffer);
00471       <span class="comment">//  END    Added for DRM support.</span>
00472 
00473       <span class="keywordflow">return</span> used;
00474     }
00475     <span class="comment">// else fall through</span>
00476   }
00477   <span class="keywordflow">case</span> DECODE_STATE_WAIT_I: {
00478     uint8_t *vophdr = MP4AV_Mpeg4FindVop(buffer, buflen);
00479     <span class="keywordflow">if</span> (vophdr != NULL) {
00480       used = vophdr - buffer;
00481     }
00482     iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;SetUpBitstreamBuffer((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)buffer + used, buflen + 3 - used);
00483     <span class="keywordflow">try</span> {
00484       iEof = iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;decode(NULL, TRUE);
00485       <span class="keywordflow">if</span> (iEof == -1) {
00486         iso-&gt;<a class="code" href="structiso__decode__t.html#o14">m_num_wait_i_frames</a>++;
00487         <span class="keywordflow">return</span>(iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;get_used_bytes());
00488       }
00489       iso_message(LOG_DEBUG, mp4iso, <span class="stringliteral">"Back to normal decode"</span>);
00490       iso-&gt;<a class="code" href="structiso__decode__t.html#o4">m_decodeState</a> = DECODE_STATE_NORMAL;
00491       iso-&gt;<a class="code" href="structiso__decode__t.html#o6">m_bCachedRefFrame</a> = FALSE;
00492       iso-&gt;<a class="code" href="structiso__decode__t.html#o7">m_bCachedRefFrameCoded</a> = FALSE;
00493       iso-&gt;<a class="code" href="structiso__decode__t.html#o9">m_cached_valid</a> = FALSE;
00494       iso-&gt;<a class="code" href="structiso__decode__t.html#o10">m_cached_time</a> = 0;
00495     } <span class="keywordflow">catch</span> (<span class="keywordtype">int</span> err) {
00496       <span class="keywordflow">if</span> (err != 1)
00497         iso_message(LOG_DEBUG, mp4iso, 
00498                     <span class="stringliteral">"ts "</span>U64<span class="stringliteral">",Caught exception in wait_i %d"</span>, 
00499                     ts-&gt;msec_timestamp, err);
00500 
00501       <span class="comment">//  BEGIN  Added for DRM support.</span>
00502       <span class="comment">//  If we performed decryption, we need to free memory.</span>
00503       <span class="keywordflow">if</span> (dBuffer != 0) free(dBuffer);
00504       <span class="comment">//  END    Added for DRM support.</span>
00505 
00506       <span class="keywordflow">return</span> (iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;get_used_bytes());
00507       <span class="comment">//return (-1);</span>
00508     }
00509     <span class="keywordflow">break</span>;
00510   }
00511   <span class="keywordflow">case</span> DECODE_STATE_NORMAL:
00512     <span class="keywordflow">try</span> {
00513       <span class="keywordflow">if</span> (iso-&gt;<a class="code" href="structiso__decode__t.html#o26">m_short_header</a> != 0) {
00514         iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;SetUpBitstreamBuffer((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)buffer, buflen + 3);
00515         iEof = iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;h263_decode(TRUE);
00516       } <span class="keywordflow">else</span> {
00517         uint8_t *vophdr = MP4AV_Mpeg4FindVop(buffer, buflen);
00518         <span class="keywordflow">if</span> (vophdr != NULL &amp;&amp; vophdr != buffer) {
00519           iso_message(LOG_DEBUG, mp4iso, <span class="stringliteral">"Illegal code before VOP header"</span>);
00520           used = vophdr - buffer;
00521           buflen -= used;
00522           buffer = vophdr;
00523         }
00524         iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;SetUpBitstreamBuffer((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)buffer, buflen + 3);
00525         iEof = iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;decode(NULL, FALSE, FALSE);
00526       }
00527     } <span class="keywordflow">catch</span> (<span class="keywordtype">int</span> err) {
00528       <span class="comment">// This is because sometimes, the encoder doesn't read all the bytes</span>
00529       <span class="comment">// it should out of the rtp packet.  The rtp bytestream does a read</span>
00530       <span class="comment">// and determines that we're trying to read across bytestreams.</span>
00531       <span class="comment">// If we get this, we don't want to change anything - just fall up</span>
00532       <span class="comment">// to the decoder thread so it gives us a new timestamp.</span>
00533       <span class="keywordflow">if</span> (err == 1) {
00534         <span class="comment">// throw from running past end of frame</span>
00535 
00536         <span class="comment">//  BEGIN  Added for DRM support.</span>
00537         <span class="comment">//  If we performed decryption, we need to free memory.</span>
00538         <span class="keywordflow">if</span> (dBuffer != 0) free(dBuffer);
00539         <span class="comment">//  END    Added for DRM support.</span>
00540 
00541               <span class="keywordflow">return</span> -1;
00542       }
00543       iso_message(LOG_DEBUG, mp4iso, 
00544                   <span class="stringliteral">"Mpeg4 ncaught %d -&gt; waiting for I"</span>, err);
00545       iso-&gt;<a class="code" href="structiso__decode__t.html#o4">m_decodeState</a> = DECODE_STATE_WAIT_I;
00546 
00547       <span class="comment">//  BEGIN  Added for DRM support.</span>
00548       <span class="comment">//  If we performed decryption, we need to free memory.</span>
00549       <span class="keywordflow">if</span> (dBuffer != 0) free(dBuffer);
00550       <span class="comment">//  END    Added for DRM support.</span>
00551 
00552       <span class="keywordflow">return</span> (iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;get_used_bytes());
00553     } <span class="keywordflow">catch</span> (...) {
00554       iso_message(LOG_DEBUG, mp4iso, 
00555                   <span class="stringliteral">"Mpeg4 ncaught -&gt; waiting for I"</span>);
00556       iso-&gt;<a class="code" href="structiso__decode__t.html#o4">m_decodeState</a> = DECODE_STATE_WAIT_I;
00557       <span class="comment">//return (-1);</span>
00558 
00559       <span class="comment">//  BEGIN  Added for DRM support.</span>
00560       <span class="comment">//  If we performed decryption, we need to free memory.</span>
00561       <span class="keywordflow">if</span> (dBuffer != 0) free(dBuffer);
00562       <span class="comment">//  END    Added for DRM support.</span>
00563 
00564       <span class="keywordflow">return</span> (iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;get_used_bytes());
00565     }
00566     <span class="keywordflow">break</span>;
00567   }
00568 
00569   <span class="comment">/*</span>
00570 <span class="comment">   * We've got a good frame.  See if we need to display it</span>
00571 <span class="comment">   */</span>
00572   <span class="keyword">const</span> CVOPU8YUVBA *pvopcQuant = NULL;
00573   <span class="keywordflow">if</span> (iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;fSptUsage() == 1) {
00574     <span class="comment">//player_debug_message("Sprite");</span>
00575   }
00576   uint64_t displaytime = 0;
00577   <span class="keywordtype">int</span> cached_ts = 0;
00578   <span class="keywordflow">if</span> (iEof == EOF) {
00579     <span class="keywordflow">if</span> (iso-&gt;<a class="code" href="structiso__decode__t.html#o6">m_bCachedRefFrame</a>) {
00580       iso-&gt;<a class="code" href="structiso__decode__t.html#o6">m_bCachedRefFrame</a> = FALSE;
00581       <span class="keywordflow">if</span> (iso-&gt;<a class="code" href="structiso__decode__t.html#o7">m_bCachedRefFrameCoded</a>) {
00582         pvopcQuant = iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;pvopcRefQLater();
00583         displaytime = ts-&gt;msec_timestamp;
00584       }
00585     }
00586   } <span class="keywordflow">else</span> {
00587 <span class="preprocessor">#if 0</span>
00588 <span class="preprocessor"></span>    iso_message(LOG_DEBUG, mp4iso, <span class="stringliteral">"frame "</span>U64<span class="stringliteral">" type %d"</span>, 
00589                 ts-&gt;msec_timestamp, iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;vopmd().vopPredType);
00590 <span class="preprocessor">#endif</span>
00591 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;vopmd().vopPredType == BVOP) {
00592       <span class="keywordflow">if</span> (iEof != FALSE) {
00593         pvopcQuant = iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;pvopcReconCurr();
00594         displaytime = ts-&gt;msec_timestamp;
00595       } 
00596     } <span class="keywordflow">else</span> {
00597       <span class="keywordflow">if</span> (iso-&gt;<a class="code" href="structiso__decode__t.html#o6">m_bCachedRefFrame</a>) {
00598         iso-&gt;<a class="code" href="structiso__decode__t.html#o6">m_bCachedRefFrame</a> = FALSE;
00599         <span class="keywordflow">if</span> (iso-&gt;<a class="code" href="structiso__decode__t.html#o7">m_bCachedRefFrameCoded</a>) {
00600           pvopcQuant = iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;pvopcRefQPrev();
00601           <span class="keywordflow">if</span> (ts-&gt;timestamp_is_pts) {
00602             <span class="keywordtype">int</span> old_was_valid = iso-&gt;<a class="code" href="structiso__decode__t.html#o9">m_cached_valid</a>;
00603             displaytime = iso-&gt;<a class="code" href="structiso__decode__t.html#o10">m_cached_time</a>;
00604             cached_ts = 1;
00605             <span class="comment">// old time stamp wasn't valid - instead of calculating it</span>
00606             <span class="comment">// ourselves, just punt on it.</span>
00607             <span class="keywordflow">if</span> (old_was_valid == 0) {
00608 
00609         <span class="comment">//  BEGIN  Added for DRM support.</span>
00610         <span class="comment">//  If we performed decryption, we need to free memory.</span>
00611         <span class="keywordflow">if</span> (dBuffer != 0) free(dBuffer);
00612         <span class="comment">//  END    Added for DRM support.</span>
00613 
00614               <span class="keywordflow">return</span> (iEof == EOF ? -1 : 0);
00615             }
00616           } <span class="keywordflow">else</span> {
00617             displaytime = ts-&gt;msec_timestamp;
00618           }
00619         }
00620       }
00621 
00622       iso-&gt;<a class="code" href="structiso__decode__t.html#o10">m_cached_time</a> = ts-&gt;msec_timestamp;
00623       iso-&gt;<a class="code" href="structiso__decode__t.html#o9">m_cached_valid</a> = TRUE;
00624       iso-&gt;<a class="code" href="structiso__decode__t.html#o6">m_bCachedRefFrame</a> = TRUE;
00625       iso-&gt;<a class="code" href="structiso__decode__t.html#o7">m_bCachedRefFrameCoded</a> = (iEof != FALSE);
00626     }
00627   }
00628 
00629   <span class="keywordflow">if</span> (pvopcQuant != NULL) {
00630 <span class="preprocessor">#if 0</span>
00631 <span class="preprocessor"></span>    player_debug_message(<span class="stringliteral">"frame rtp_ts "</span>U64<span class="stringliteral">" disp "</span>U64<span class="stringliteral">" cached %d"</span>, 
00632                          ts-&gt;msec_timestamp, displaytime, cached_ts);
00633 <span class="preprocessor">#endif</span>
00634 <span class="preprocessor"></span>    <span class="comment">/*</span>
00635 <span class="comment">     * Get the information to the video sync structure</span>
00636 <span class="comment">     */</span>
00637     <span class="keyword">const</span> uint8_t *y, *u, *v;
00638     <span class="keywordtype">int</span> pixelw_y, pixelw_uv;
00639     pixelw_y =  pvopcQuant-&gt;getPlane(Y_PLANE)-&gt;where().width;
00640     pixelw_uv = pvopcQuant-&gt;getPlane(U_PLANE)-&gt;where().width;
00641 
00642     y = (<span class="keyword">const</span> uint8_t *)pvopcQuant-&gt;getPlane(Y_PLANE)-&gt;pixels(0,0);
00643     u = (<span class="keyword">const</span> uint8_t *)pvopcQuant-&gt;getPlane(U_PLANE)-&gt;pixels(0,0);
00644     v = (<span class="keyword">const</span> uint8_t *)pvopcQuant-&gt;getPlane(V_PLANE)-&gt;pixels(0,0);
00645     iso-&gt;<a class="code" href="structiso__decode__t.html#o11">m_last_time</a> = displaytime;
00646 <span class="preprocessor">#if 0</span>
00647 <span class="preprocessor"></span>    player_debug_message(<span class="stringliteral">"Adding video at "</span>U64<span class="stringliteral">" %d"</span>, displaytime,
00648                          iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;vopmd().vopPredType);
00649 <span class="preprocessor">#endif</span>
00650 <span class="preprocessor"></span>
00651     iso-&gt;m_vft-&gt;video_have_frame(iso-&gt;m_ifptr, 
00652                                 y, 
00653                                 u, 
00654                                 v, 
00655                                 pixelw_y, 
00656                                 pixelw_uv, 
00657                                 displaytime);
00658   } <span class="keywordflow">else</span> {
00659     iso_message(LOG_DEBUG, mp4iso, <span class="stringliteral">"decode but no frame "</span>U64, ts-&gt;msec_timestamp);
00660   }
00661 
00662   <span class="comment">//  BEGIN  Added for DRM support.</span>
00663   <span class="comment">//  If we performed decryption, we need to free memory.</span>
00664   <span class="keywordflow">if</span> (dBuffer != 0) free(dBuffer);
00665   <span class="comment">//  END    Added for DRM support.</span>
00666 
00667   <span class="keywordflow">return</span> (iso-&gt;<a class="code" href="structiso__decode__t.html#o1">m_pvodec</a>-&gt;get_used_bytes() + used);
00668 }
00669 
00670 <span class="keyword">static</span> <span class="keywordtype">int</span> iso_skip_frame (codec_data_t *iso)
00671 {
00672 <span class="preprocessor">#if 0</span>
00673 <span class="preprocessor"></span>  <span class="keywordflow">return</span> (<a class="code" href="mpeg4_8cpp.html#a13">iso_decode</a>(iso, ts, 0, NULL, buffer, buflen));
00674 <span class="preprocessor">#else</span>
00675 <span class="preprocessor"></span>  <span class="keywordflow">return</span> 0;
00676 <span class="preprocessor">#endif</span>
00677 <span class="preprocessor"></span>}
00678 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *iso_compressors[] = {
00679   <span class="stringliteral">"mp4 "</span>, 
00680   <span class="stringliteral">"mp4v"</span>,
00681   <span class="stringliteral">"encv"</span>,
00682   <span class="stringliteral">"divx"</span>, 
00683   <span class="stringliteral">"dvx1"</span>, 
00684   <span class="stringliteral">"div4"</span>, 
00685   <span class="stringliteral">"mpeg4"</span>, 
00686   <span class="stringliteral">"xvid"</span>,
00687   NULL,
00688 };
00689 
00690 <span class="keyword">static</span> <span class="keywordtype">int</span> iso_codec_check (lib_message_func_t message,
00691                             <span class="keyword">const</span> <span class="keywordtype">char</span> *stream_type,
00692                             <span class="keyword">const</span> <span class="keywordtype">char</span> *compressor,
00693                             <span class="keywordtype">int</span> type,
00694                             <span class="keywordtype">int</span> profile,
00695                             format_list_t *fptr,
00696                             <span class="keyword">const</span> uint8_t *userdata,
00697                             uint32_t userdata_size,
00698                             CConfigSet *pConfig)
00699 {
00700   <span class="keywordtype">int</span> ret_val = -1;
00701 
00702   <span class="keywordflow">if</span> (strcasecmp(stream_type, STREAM_TYPE_MP4_FILE) == 0) {
00703     <span class="keywordflow">if</span> (strcasecmp(compressor, <span class="stringliteral">"mp4v"</span>) == 0 ||
00704         strcasecmp(compressor, <span class="stringliteral">"encv"</span>) == 0 &amp;&amp;
00705         (type == MP4_MPEG4_VIDEO_TYPE || type == MP4_H263_VIDEO_TYPE)) {
00706       ret_val =  1;
00707     }
00708   }
00709 
00710   <span class="keywordflow">if</span> (strcasecmp(stream_type, STREAM_TYPE_RTP) == 0 &amp;&amp;
00711       fptr != NULL) {
00712     <span class="comment">// find format. If matches, call parse_fmtp_for_mpeg4, look at</span>
00713     <span class="comment">// profile level.</span>
00714 <span class="preprocessor">#if 1</span>
00715 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (strcmp(fptr-&gt;fmt, <span class="stringliteral">"34"</span>) == 0) {
00716       ret_val =  1;
00717     }
00718 <span class="preprocessor">#endif</span>
00719 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (fptr-&gt;rtpmap != NULL &amp;&amp; fptr-&gt;rtpmap-&gt;encode_name != NULL) {
00720       <span class="keywordflow">if</span> (strcasecmp(fptr-&gt;rtpmap-&gt;encode_name, <span class="stringliteral">"MP4V-ES"</span>) == 0 || 
00721           strcasecmp(fptr-&gt;rtpmap-&gt;encode_name, <span class="stringliteral">"enc-mpeg4-generic"</span>) == 0) {
00722         ret_val =  1;
00723       }
00724     }
00725   }
00726 
00727   <span class="keywordflow">if</span> (compressor != NULL) {
00728     <span class="keyword">const</span> <span class="keywordtype">char</span> **lptr = iso_compressors;
00729     <span class="keywordflow">while</span> (*lptr != NULL) {
00730       <span class="keywordflow">if</span> (strcasecmp(*lptr, compressor) == 0) {
00731         ret_val =  1;
00732         <span class="keywordflow">break</span>;
00733       }
00734       lptr++;
00735     }
00736   }
00737   <span class="keywordflow">if</span> (ret_val == 1 &amp;&amp; pConfig-&gt;GetBoolValue(CONFIG_USE_MPEG4_ISO_ONLY)) {
00738     
00739     ret_val = 255;
00740     message(LOG_DEBUG, <span class="stringliteral">"mpeg4iso"</span>, <span class="stringliteral">"Asserting mpeg4 iso only"</span>);
00741   }
00742   <span class="keywordflow">return</span> ret_val;
00743 }
00744 
00745 VIDEO_CODEC_WITH_RAW_FILE_PLUGIN(<span class="stringliteral">"MPEG4 ISO"</span>, 
00746                                  iso_create,
00747                                  iso_do_pause,
00748                                  <a class="code" href="mpeg4_8cpp.html#a13">iso_decode</a>,
00749                                  NULL,
00750                                  iso_close,
00751                                  iso_codec_check,
00752                                  iso_frame_is_sync,
00753                                  mpeg4_iso_file_check,
00754                                  divx_file_next_frame,
00755                                  divx_file_used_for_frame,
00756                                  divx_file_seek_to,
00757                                  iso_skip_frame,
00758                                  divx_file_eof,
00759                                  MyConfigVariables,
00760                                  <span class="keyword">sizeof</span>(MyConfigVariables) / 
00761                                  <span class="keyword">sizeof</span>(*MyConfigVariables));
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sat Jun 10 19:21:00 2006 for "MPEG4IP with DRM support" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
