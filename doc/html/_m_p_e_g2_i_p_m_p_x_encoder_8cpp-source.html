<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>&quot;DRM Plugin Architecture&quot;: MPEG2IPMPXEncoder.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>MPEG2IPMPXEncoder.cpp</h1><a href="_m_p_e_g2_i_p_m_p_x_encoder_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00014 <span class="preprocessor">#include "<a class="code" href="_m_p_e_g2_i_p_m_p_x_encoder_8h.html">MPEG2IPMPXEncoder.h</a>"</span>
00015 
00016 <span class="preprocessor">#include "<a class="code" href="_basic_types_8h.html">BasicTypes.h</a>"</span>
00017 <span class="preprocessor">#include "<a class="code" href="_i_i_p_m_p_control_info_part_8h.html">IIPMPControlInfoPart.h</a>"</span>
00018 
00019 <span class="preprocessor">#include "<a class="code" href="_i_p_m_p_control_info_part_8h.html">IPMPControlInfoPart.h</a>"</span>
00020 <span class="preprocessor">#include "<a class="code" href="_i_m_p_e_g2_i_p_m_p_x_encoder_8h.html">IMPEG2IPMPXEncoder.h</a>"</span>
00021 
00022 <span class="preprocessor">#include "<a class="code" href="_m_p_e_g2_i_p_m_p_x_d_r_m_encoder_8h.html">MPEG2IPMPXDRMEncoder.h</a>"</span>
00023 <span class="preprocessor">#include "<a class="code" href="_i_p_m_p_descriptor_8h.html">IPMPDescriptor.h</a>"</span>
00024 
00026 <span class="keyword">namespace </span>DRMPlugin {
00027 
00029 <span class="keyword">namespace </span>MPEG2IPMPXDRMPlugin {
00030 
<a name="l00049"></a><a class="code" href="class_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_t_stream_encoder.html#a2">00049</a> <span class="keywordtype">bool</span> <a class="code" href="class_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_t_stream_encoder.html#a2">MPEG2IPMPXTStreamEncoder::CreateInterIPMPControlInfoPart</a>(
00050     <a class="code" href="class_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_plugin_1_1_i_inter_t_stream_i_p_m_p_control_info_part.html">IInterTStreamIPMPControlInfoPart</a>** interPart) {
00051   inter.push_back(<span class="keyword">new</span> <a class="code" href="class_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_plugin_1_1_inter_t_stream_i_p_m_p_control_info_part.html">InterTStreamIPMPControlInfoPart</a>());
00052   *interPart = inter.back();
00053   <span class="keywordflow">return</span> <span class="keyword">true</span>;
00054 }
00055 
<a name="l00067"></a><a class="code" href="class_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_t_stream_encoder.html#a3">00067</a> <span class="keywordtype">bool</span> <a class="code" href="class_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_t_stream_encoder.html#a3">MPEG2IPMPXTStreamEncoder::CreateLastIPMPControlInfoPart</a>(
00068     <a class="code" href="class_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_plugin_1_1_i_last_t_stream_i_p_m_p_control_info_part.html">ILastTStreamIPMPControlInfoPart</a>** lastPart) {
00069   <span class="keywordflow">if</span> (last != 0) <span class="keyword">delete</span> last;
00070   last = <span class="keyword">new</span> <a class="code" href="class_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_plugin_1_1_last_t_stream_i_p_m_p_control_info_part.html">LastTStreamIPMPControlInfoPart</a>();
00071   *lastPart = last;
00072   <span class="keywordflow">return</span> <span class="keyword">true</span>;
00073 }
00074 
<a name="l00088"></a><a class="code" href="class_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_t_stream_encoder.html#a4">00088</a> <span class="keywordtype">bool</span> <a class="code" href="class_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_t_stream_encoder.html#a4">MPEG2IPMPXTStreamEncoder::Encode</a>(std::string&amp; in, <span class="keyword">const</span> std::string&amp; out,
00089     <a class="code" href="class_d_r_m_plugin_1_1_i_x_m_l_element.html">IXMLElement</a>* xml, <a class="code" href="namespace_d_r_m_plugin.html#a9">EncMethod</a> method) {
00090   <a class="code" href="class_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_encoder.html">MPEG2IPMPXDRMEncoder</a> drmEncoder(encLogger);
00091   <a class="code" href="class_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_plugin_1_1_i_m_p_e_g2_i_p_m_p_x_d_r_m_encryptor.html">IMPEG2IPMPXDRMEncryptor</a>* encryptor = 0;
00092 
00093   <span class="comment">//  Create MPEG2Encryptor that will protect the content.</span>
00094   <span class="keywordflow">if</span> (drmEncoder.<a class="code" href="class_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_encoder.html#a2">CreateMPEG2IPMPXDRMEncryptor</a>(in, xml, method, &amp;encryptor) == <span class="keyword">false</span>) {
00095     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00096   }
00097 
00098   <span class="comment">//  Create new IPMP descriptor for this stream which will contain</span>
00099   <span class="comment">//  DRM information.</span>
00100   <a class="code" href="class_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_plugin_1_1_i_p_m_p_descriptor.html">IPMPDescriptor</a>* ipmpDesc = <span class="keyword">new</span> <a class="code" href="class_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_plugin_1_1_i_p_m_p_descriptor.html">IPMPDescriptor</a>();
00101 
00102   <span class="comment">//  Add DRM information to IPMP descriptor for this stream.</span>
00103   <span class="keywordflow">if</span> (encryptor-&gt;<a class="code" href="class_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_plugin_1_1_i_m_p_e_g2_i_p_m_p_x_d_r_m_encryptor.html#a2">AddDRMInfo</a>(ipmpDesc) == <span class="keyword">false</span>) {
00104     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00105   }
00106 
00107   <span class="comment">//  Finally add DRM information for all streams (control class infos).</span>
00108   <span class="keywordflow">if</span> (drmEncoder.<a class="code" href="class_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_encoder.html#a3">AddDRMInfo</a>(<span class="keyword">this</span>) == <span class="keyword">false</span>) {
00109     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00110   }
00111 
00112   <span class="comment">//  Now write everything to output file.</span>
00113   FILE* output = fopen(out.data(), <span class="stringliteral">"wb"</span>);
00114   <span class="keywordflow">if</span> (output == NULL) {
00115     <span class="keyword">delete</span> ipmpDesc;
00116     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00117   }
00118 
00119   <a class="code" href="class_d_r_m_plugin_1_1_byte_seq.html">ByteSeq</a> encoded;
00120   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; inter.size(); i++) {
00121     <span class="keywordflow">if</span> (inter[i]-&gt;<a class="code" href="class_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_t_stream_encoder.html#a4">Encode</a>(encoded) == <span class="keyword">false</span>) {
00122       fclose(output);
00123       <span class="keyword">delete</span> ipmpDesc;
00124       <span class="keywordflow">return</span> <span class="keyword">false</span>;
00125     }
00126     fwrite(encoded.<a class="code" href="class_d_r_m_plugin_1_1_byte_seq.html#a20">GetFirst</a>(), encoded.<a class="code" href="class_d_r_m_plugin_1_1_byte_seq.html#a21">GetLength</a>(), 1, output);
00127   }
00128   <span class="keywordflow">if</span> (last-&gt;<a class="code" href="class_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_plugin_1_1_last_t_stream_i_p_m_p_control_info_part.html#a21">Encode</a>(encoded) == <span class="keyword">false</span>) {
00129     fclose(output);
00130     <span class="keyword">delete</span> ipmpDesc;
00131     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00132   }
00133   fwrite(encoded.<a class="code" href="class_d_r_m_plugin_1_1_byte_seq.html#a20">GetFirst</a>(), encoded.<a class="code" href="class_d_r_m_plugin_1_1_byte_seq.html#a21">GetLength</a>(), 1, output);
00134 
00135   <span class="keywordflow">if</span> (ipmpDesc-&gt;<a class="code" href="class_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_plugin_1_1_i_p_m_p_descriptor.html#a15">Encode</a>(encoded) == <span class="keyword">false</span>) {
00136     fclose(output);
00137     <span class="keyword">delete</span> ipmpDesc;
00138     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00139   }
00140   fwrite(encoded.<a class="code" href="class_d_r_m_plugin_1_1_byte_seq.html#a20">GetFirst</a>(), encoded.<a class="code" href="class_d_r_m_plugin_1_1_byte_seq.html#a21">GetLength</a>(), 1, output);
00141   <span class="keyword">delete</span> ipmpDesc;
00142 
00143   <span class="comment">//  This should be done before adding DRM information, but it complicates</span>
00144   <span class="comment">//  test encoding, and provides no new test cases, thus we do it here.</span>
00145   <span class="comment">//  Read from input file and write to output file.</span>
00146   FILE* input = fopen(in.data(), <span class="stringliteral">"rb"</span>);
00147   ByteT buffer[200*1024];
00148   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> read = 0;
00149   <span class="keywordflow">while</span> ((read = fread(buffer, 200*1024, 1, input)) &gt; 0) {
00150     <span class="comment">//  Create ByteSeq, pass it to encryptor for protection and write</span>
00151     <span class="comment">//  to output file.</span>
00152     <a class="code" href="class_d_r_m_plugin_1_1_byte_seq.html">ByteSeq</a> plain(buffer, read*(200*1024)), encrypted;
00153     <span class="keywordflow">if</span> (encryptor-&gt;<a class="code" href="class_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_plugin_1_1_i_m_p_e_g2_i_p_m_p_x_d_r_m_encryptor.html#a1">EncryptData</a>(plain, encrypted) == <span class="keyword">false</span>) {
00154       fclose(input);
00155       fclose(output);
00156       <span class="keywordflow">return</span> <span class="keyword">false</span>;
00157     }
00158     <span class="comment">//  Write length of the encrypted data, for the decoder to be able to</span>
00159     <span class="comment">//  correctly read it later.</span>
00160     UInt32T length = encrypted.<a class="code" href="class_d_r_m_plugin_1_1_byte_seq.html#a21">GetLength</a>();
00161     ByteT len[4];
00162     len[0] = (ByteT)((length &gt;&gt; 24) &amp; 0xff);
00163     len[1] = (ByteT)((length &gt;&gt; 16) &amp; 0xff);
00164     len[2] = (ByteT)((length &gt;&gt; 8) &amp; 0xff);
00165     len[3] = (ByteT)(length &amp; 0xff);
00166     fwrite(len, 4, 1, output);
00167     fwrite(encrypted.<a class="code" href="class_d_r_m_plugin_1_1_byte_seq.html#a20">GetFirst</a>(), encrypted.<a class="code" href="class_d_r_m_plugin_1_1_byte_seq.html#a21">GetLength</a>(), 1, output);
00168   }
00169   fclose(input);
00170   fclose(output);
00171 
00172   <span class="keywordflow">return</span> <span class="keyword">true</span>;
00173 }
00174 
<a name="l00193"></a><a class="code" href="class_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_p_stream_encoder.html#a2">00193</a> <span class="keywordtype">bool</span> <a class="code" href="class_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_p_stream_encoder.html#a2">MPEG2IPMPXPStreamEncoder::CreateInterIPMPControlInfoPart</a>(
00194     <a class="code" href="class_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_plugin_1_1_i_inter_p_stream_i_p_m_p_control_info_part.html">IInterPStreamIPMPControlInfoPart</a>** interPart) {
00195   inter.push_back(<span class="keyword">new</span> <a class="code" href="class_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_plugin_1_1_inter_p_stream_i_p_m_p_control_info_part.html">InterPStreamIPMPControlInfoPart</a>());
00196   *interPart = inter.back();
00197   <span class="keywordflow">return</span> <span class="keyword">true</span>;
00198 }
00199 
<a name="l00211"></a><a class="code" href="class_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_p_stream_encoder.html#a3">00211</a> <span class="keywordtype">bool</span> <a class="code" href="class_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_p_stream_encoder.html#a3">MPEG2IPMPXPStreamEncoder::CreateLastIPMPControlInfoPart</a>(
00212     <a class="code" href="class_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_plugin_1_1_i_last_p_stream_i_p_m_p_control_info_part.html">ILastPStreamIPMPControlInfoPart</a>** lastPart) {
00213   <span class="keywordflow">if</span> (last != 0) <span class="keyword">delete</span> last;
00214   last = <span class="keyword">new</span> <a class="code" href="class_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_plugin_1_1_last_p_stream_i_p_m_p_control_info_part.html">LastPStreamIPMPControlInfoPart</a>();
00215   *lastPart = last;
00216   <span class="keywordflow">return</span> <span class="keyword">true</span>;
00217 }
00218 
<a name="l00232"></a><a class="code" href="class_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_p_stream_encoder.html#a4">00232</a> <span class="keywordtype">bool</span> <a class="code" href="class_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_p_stream_encoder.html#a4">MPEG2IPMPXPStreamEncoder::Encode</a>(std::string&amp; in, <span class="keyword">const</span> std::string&amp; out,
00233     <a class="code" href="class_d_r_m_plugin_1_1_i_x_m_l_element.html">IXMLElement</a>* xml, <a class="code" href="namespace_d_r_m_plugin.html#a9">EncMethod</a> method) {
00234   <a class="code" href="class_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_encoder.html">MPEG2IPMPXDRMEncoder</a> drmEncoder(encLogger);
00235   <a class="code" href="class_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_plugin_1_1_i_m_p_e_g2_i_p_m_p_x_d_r_m_encryptor.html">IMPEG2IPMPXDRMEncryptor</a>* encryptor = 0;
00236 
00237   <span class="comment">//  Create MPEG2Encryptor that will protect the content.</span>
00238   <span class="keywordflow">if</span> (drmEncoder.<a class="code" href="class_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_encoder.html#a2">CreateMPEG2IPMPXDRMEncryptor</a>(in, xml, method, &amp;encryptor) == <span class="keyword">false</span>) {
00239     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00240   }
00241 
00242   <span class="comment">//  Create new IPMP descriptor for this stream which will contain</span>
00243   <span class="comment">//  DRM information.</span>
00244   <a class="code" href="class_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_plugin_1_1_i_p_m_p_descriptor.html">IPMPDescriptor</a>* ipmpDesc = <span class="keyword">new</span> <a class="code" href="class_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_plugin_1_1_i_p_m_p_descriptor.html">IPMPDescriptor</a>();
00245 
00246   <span class="comment">//  Add DRM information to IPMP descriptor for this stream.</span>
00247   <span class="keywordflow">if</span> (encryptor-&gt;<a class="code" href="class_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_plugin_1_1_i_m_p_e_g2_i_p_m_p_x_d_r_m_encryptor.html#a2">AddDRMInfo</a>(ipmpDesc) == <span class="keyword">false</span>) {
00248     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00249   }
00250 
00251   <span class="comment">//  Finally add DRM information for all streams (control class infos).</span>
00252   <span class="keywordflow">if</span> (drmEncoder.<a class="code" href="class_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_encoder.html#a3">AddDRMInfo</a>(<span class="keyword">this</span>) == <span class="keyword">false</span>) {
00253     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00254   }
00255 
00256   <span class="comment">//  Now write everything to output file.</span>
00257   FILE* output = fopen(out.data(), <span class="stringliteral">"wb"</span>);
00258   <span class="keywordflow">if</span> (output == NULL) {
00259     <span class="keyword">delete</span> ipmpDesc;
00260     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00261   }
00262 
00263   <a class="code" href="class_d_r_m_plugin_1_1_byte_seq.html">ByteSeq</a> encoded;
00264   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; inter.size(); i++) {
00265     <span class="keywordflow">if</span> (inter[i]-&gt;<a class="code" href="class_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_p_stream_encoder.html#a4">Encode</a>(encoded) == <span class="keyword">false</span>) {
00266       fclose(output);
00267       <span class="keyword">delete</span> ipmpDesc;
00268       <span class="keywordflow">return</span> <span class="keyword">false</span>;
00269     }
00270     fwrite(encoded.<a class="code" href="class_d_r_m_plugin_1_1_byte_seq.html#a20">GetFirst</a>(), encoded.<a class="code" href="class_d_r_m_plugin_1_1_byte_seq.html#a21">GetLength</a>(), 1, output);
00271   }
00272   <span class="keywordflow">if</span> (last-&gt;<a class="code" href="class_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_plugin_1_1_last_p_stream_i_p_m_p_control_info_part.html#a27">Encode</a>(encoded) == <span class="keyword">false</span>) {
00273     fclose(output);
00274     <span class="keyword">delete</span> ipmpDesc;
00275     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00276   }
00277   fwrite(encoded.<a class="code" href="class_d_r_m_plugin_1_1_byte_seq.html#a20">GetFirst</a>(), encoded.<a class="code" href="class_d_r_m_plugin_1_1_byte_seq.html#a21">GetLength</a>(), 1, output);
00278 
00279   <span class="keywordflow">if</span> (ipmpDesc-&gt;<a class="code" href="class_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_plugin_1_1_i_p_m_p_descriptor.html#a15">Encode</a>(encoded) == <span class="keyword">false</span>) {
00280     fclose(output);
00281     <span class="keyword">delete</span> ipmpDesc;
00282     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00283   }
00284   fwrite(encoded.<a class="code" href="class_d_r_m_plugin_1_1_byte_seq.html#a20">GetFirst</a>(), encoded.<a class="code" href="class_d_r_m_plugin_1_1_byte_seq.html#a21">GetLength</a>(), 1, output);
00285   <span class="keyword">delete</span> ipmpDesc;
00286 
00287   <span class="comment">//  This should be done before adding DRM information, but it complicates</span>
00288   <span class="comment">//  test encoding, and provides no new test cases, thus we do it here.</span>
00289   <span class="comment">//  Read from input file and write to output file.</span>
00290   FILE* input = fopen(in.data(), <span class="stringliteral">"rb"</span>);
00291   ByteT buffer[200*1024];
00292   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> read = 0;
00293   <span class="keywordflow">while</span> ((read = fread(buffer, 200*1024, 1, input)) &gt; 0) {
00294     <span class="comment">//  Create ByteSeq, pass it to encryptor for protection and write</span>
00295     <span class="comment">//  to output file.</span>
00296     <a class="code" href="class_d_r_m_plugin_1_1_byte_seq.html">ByteSeq</a> plain(buffer, read*(200*1024)), encrypted;
00297     <span class="keywordflow">if</span> (encryptor-&gt;<a class="code" href="class_d_r_m_plugin_1_1_m_p_e_g2_i_p_m_p_x_d_r_m_plugin_1_1_i_m_p_e_g2_i_p_m_p_x_d_r_m_encryptor.html#a1">EncryptData</a>(plain, encrypted) == <span class="keyword">false</span>) {
00298       fclose(input);
00299       fclose(output);
00300       <span class="keywordflow">return</span> <span class="keyword">false</span>;
00301     }
00302     <span class="comment">//  Write length of the encrypted data, for the decoder to be able to</span>
00303     <span class="comment">//  correctly read it later.</span>
00304     UInt32T length = encrypted.<a class="code" href="class_d_r_m_plugin_1_1_byte_seq.html#a21">GetLength</a>();
00305     ByteT len[4];
00306     len[0] = (ByteT)((length &gt;&gt; 24) &amp; 0xff);
00307     len[1] = (ByteT)((length &gt;&gt; 16) &amp; 0xff);
00308     len[2] = (ByteT)((length &gt;&gt; 8) &amp; 0xff);
00309     len[3] = (ByteT)(length &amp; 0xff);
00310     fwrite(len, 4, 1, output);
00311     fwrite(encrypted.<a class="code" href="class_d_r_m_plugin_1_1_byte_seq.html#a20">GetFirst</a>(), encrypted.<a class="code" href="class_d_r_m_plugin_1_1_byte_seq.html#a21">GetLength</a>(), 1, output);
00312   }
00313   fclose(input);
00314   fclose(output);
00315 
00316   <span class="keywordflow">return</span> <span class="keyword">true</span>;
00317 }
00318 
00319 } <span class="comment">// namespace MPEG2IPMPXDRMPlugin</span>
00320 
00321 } <span class="comment">// namespace DRMPlugin</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sat Jun 10 19:17:59 2006 for "DRM Plugin Architecture" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
