
package se.anatom.ejbca.apply;

import java.io.*;
import java.net.*;
import java.text.*;
import java.util.*;
import java.security.cert.*;
import java.security.spec.X509EncodedKeySpec;
import java.security.Provider;
import java.security.Security;

import javax.servlet.*;
import javax.servlet.http.*;
import javax.ejb.*;

import javax.rmi.PortableRemoteObject;
import javax.naming.InitialContext;

import se.anatom.ejbca.util.Base64;

import org.apache.log4j.*;

import org.bouncycastle.asn1.*;
import org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;
import org.bouncycastle.asn1.util.*;
import org.bouncycastle.jce.*;
import org.bouncycastle.jce.netscape.*;
import org.bouncycastle.jce.provider.*;

import se.anatom.ejbca.ca.sign.ISignSessionHome;
import se.anatom.ejbca.ca.sign.ISignSessionRemote;
import se.anatom.ejbca.util.CertTools;
import se.anatom.ejbca.util.FileTools;
import se.anatom.ejbca.ca.exception.AuthStatusException;
import se.anatom.ejbca.ca.exception.AuthLoginException;
import se.anatom.ejbca.ca.exception.SignRequestException;
import se.anatom.ejbca.ca.exception.SignRequestSignatureException;

/**
 * Servlet used to install a private key with a corresponding certificate in a
 * browser. A new certificate is installed in the browser in following steps:<br>
 *
 * 1. The key pair is generated by the browser. <br>
 *
 * 2. The public part is sent to the servlet in a post together with user info
 *    ("pkcs10|keygen", "inst", "user", "password"). For internet explorer the public key
 *    is sent as a PKCS10 certificate request. <br>
 *
 * 3. The new certificate is created by calling the RSASignSession session bean. <br>
 *
 * 4. A page containing the new certificate and a script that installs it is returned
 *    to the browser. <br>
 * <p>
 * <p>
 * The following initiation parameters are needed by this servlet: <br>
 *
 * "responseTemplate" file that defines the response to the user (IE). It should have one
 * line with the text "cert =". This line is replaced with the new certificate.
 * "keyStorePass". Password needed to load the key-store. If this parameter is none
 * existing it is assumed that no password is needed. The path could be absolute or
 * relative.<br>
 *
 * @author Original code by Lars Silv?n
 * @version $Id: CertReqServlet.java,v 1.1 2006/06/09 17:09:06 danijel Exp $
 */
public class CertReqServlet extends HttpServlet {

    static private Category cat = Category.getInstance( CertReqServlet.class.getName() );

    private InitialContext ctx = null;
    ISignSessionHome home = null;

    public void init(ServletConfig config) throws ServletException {
    super.init(config);
        try {
            // Install BouncyCastle provider
            Provider BCJce = new org.bouncycastle.jce.provider.BouncyCastleProvider();
            int result = Security.addProvider(BCJce);

            // Get EJB context and home interfaces
            ctx = new InitialContext();
            home = (ISignSessionHome) PortableRemoteObject.narrow(
            ctx.lookup("RSASignSession"), ISignSessionHome.class );
        } catch( Exception e ) {
            throw new ServletException(e);
        }
    }

    public void doPost(HttpServletRequest request, HttpServletResponse response)
        throws IOException {
        response.setContentType("text/html");

        Debug debug = new Debug();
        try {
            String username = request.getParameter("user");
            String password = request.getParameter("password");
            cat.info("Got request for " + username + "/" + password);
            debug.print("<h3>username: "+username+"</h3>");
            // first check if it is a netcsape request,
            if (request.getParameter("keygen") != null) {
                byte[] reqBytes=request.getParameter("keygen").getBytes();
                cat.debug("Received NS request:"+new String(reqBytes));
                if (reqBytes != null) {
                    byte[] certs = nsCertRequest(reqBytes, username, password, debug);
                    sendNewCertToNSClient(certs, response);
                }
            } else if ( (request.getParameter("pkcs10") != null) || (request.getParameter("PKCS10") != null) ) {
                // if not netscape, check if it's IE
                byte[] reqBytes=request.getParameter("pkcs10").getBytes();
                if (reqBytes == null)
                    reqBytes=request.getParameter("PKCS10").getBytes();
                cat.debug("Received IE request:"+new String(reqBytes));
                if (reqBytes != null) {
                    byte[] b64cert=pkcs10CertRequest(
                        reqBytes, username, password, debug);
                    debug.ieCertFix(b64cert);
                    sendNewCertToIEClient(b64cert, response.getOutputStream());
                }
            } else if (request.getParameter("pkcs10req") != null) {
                // if not IE, check if it's manual request
                byte[] reqBytes=request.getParameter("pkcs10req").getBytes();
                if (reqBytes != null) {
                    byte[] b64cert=pkcs10CertRequest(
                        reqBytes, username, password, debug);
                    sendNewB64Cert(b64cert, response);
                }
            }
        } catch (ObjectNotFoundException oe) {
            debug.printMessage("Non existent username!");
            debug.printMessage("To generate a certificate a valid username and password must be entered.");
            debug.printDebugInfo(response.getOutputStream());
            return;
        } catch (AuthStatusException ase) {
            debug.printMessage("Wrong user status!");
            debug.printMessage("To generate a certificate for a user the user must have status new, failed or inprocess.");
            debug.printDebugInfo(response.getOutputStream());
            return;
        } catch (AuthLoginException ale) {
            debug.printMessage("Wrong username or password!");
            debug.printMessage("To generate a certificate a valid username and password must be entered.");
            debug.printDebugInfo(response.getOutputStream());
            return;
        } catch (SignRequestException re) {
            cat.error("Invalid request!");
            debug.printMessage("Invalid request!");
            debug.printMessage("Please supply a correct request.");
            debug.printDebugInfo(response.getOutputStream());
            return;
        } catch (SignRequestSignatureException se) {
            cat.error("Invalid signature on certificate request!");
            debug.printMessage("Invalid signature on certificate request!");
            debug.printMessage("Please supply a correctly signed request.");
            debug.printDebugInfo(response.getOutputStream());
            return;
        } catch (java.lang.ArrayIndexOutOfBoundsException ae) {
            cat.error("Empty or invalid request received.");
            debug.printMessage("Empty or invalid request!");
            debug.printMessage("Please supply a correct request.");
            debug.printDebugInfo(response.getOutputStream());
            return;
        } catch (Exception e) {
            cat.error(e);
            debug.print("<h3>parameter name and values: </h3>");
            Enumeration paramNames=request.getParameterNames();
            while (paramNames.hasMoreElements()) {
                String name=paramNames.nextElement().toString();
                String parameter=request.getParameter(name);
                debug.print("<h4>"+name+":</h4>"+parameter+"<br>");
            }
            debug.takeCareOfException(e);
            debug.printDebugInfo(response.getOutputStream());
        }
    } //doPost

    public void doGet(HttpServletRequest req,  HttpServletResponse res) throws java.io.IOException, ServletException {
        cat.debug(">doGet()");
        res.setContentType("text/html");
        res.getOutputStream().println("The certificate request servlet only handles POST method.");
        cat.debug("<doGet()");
    } // doGet

    private void ieCertFormat(byte[] bA, PrintStream out) throws Exception {
        BufferedReader br=new BufferedReader(
            new InputStreamReader(new ByteArrayInputStream(bA)) );
        int rowNr=0;
        while ( true ){
            String line=br.readLine();
            if (line==null)
                break;
            if ( line.indexOf("END CERT")<0 ) {
                if ( line.indexOf(" CERT")<0 ) {
                    if ( ++rowNr>1 )
                        out.println(" & _ ");
                    else
                        out.print("    cert = ");
                    out.print('\"'+line+'\"');
                }
            } else
                break;
        }
        out.println();
    }

    private void sendNewCertToIEClient(byte[] b64cert, OutputStream out)
        throws Exception {
        PrintStream ps = new PrintStream(out);
        BufferedReader br = new BufferedReader(
            new InputStreamReader(
                getServletContext().getResourceAsStream(
                    getInitParameter("responseTemplate"))
                    ));
        while ( true ){
            String line=br.readLine();
            if ( line==null )
                break;
            if ( line.indexOf("cert =")<0 )
                ps.println(line);
            else
                ieCertFormat(b64cert, ps);
        }
        ps.close();
        cat.info("Sent reply to IE client");
        cat.debug(new String(b64cert));
    }

    private void sendNewCertToNSClient(byte[] certs, HttpServletResponse out)
        throws Exception {
        // Set content-type to what NS wants
        out.setContentType("application/x-x509-user-cert");
        out.setContentLength(certs.length);
        // Print the certificate
        out.getOutputStream().write(certs);
        cat.info("Sent reply to NS client");
        cat.debug(new String(Base64.encode(certs)));
    }
    private void sendNewB64Cert(byte[] b64cert, HttpServletResponse out)
        throws Exception {
        // Set content-type to general file
        out.setContentType("application/octet-stream");
        out.setHeader("Content-disposition", "attachment; filename=cert.pem");
        String beg = "-----BEGIN CERTIFICATE-----\n";
        String end = "\n-----END CERTIFICATE-----\n";
        out.setContentLength(b64cert.length+beg.length()+end.length());
        // Write the certificate
        ServletOutputStream os = out.getOutputStream();
        os.write(beg.getBytes());
        os.write(b64cert);
        os.write(end.getBytes());
        out.flushBuffer();
        cat.info("Sent reply to client");
        cat.debug(new String(b64cert));
    }

    /**
     * Handles NetScape certificate request (KEYGEN), these are constructed as:
     * <pre><code>
     *   SignedPublicKeyAndChallenge ::= SEQUENCE {
     *     publicKeyAndChallenge    PublicKeyAndChallenge,
     *     signatureAlgorithm   AlgorithmIdentifier,
     *     signature        BIT STRING
     *   }
     * </pre>
     *
     * PublicKey's encoded-format has to be RSA X.509.
     * @return byte[] containing DER-encoded certificate.
     */
    private byte[] nsCertRequest(byte[] reqBytes, String username, String password, Debug debug)
        throws Exception {
            byte[] buffer = Base64.decode(reqBytes);
            DERInputStream  in = new DERInputStream(new ByteArrayInputStream(buffer));
            DERConstructedSequence spkac = (DERConstructedSequence)in.readObject();
            NetscapeCertRequest nscr = new NetscapeCertRequest (spkac);
            // Verify POPO, we don't care about the challenge, it's not important.
            nscr.setChallenge("challenge");
            if (nscr.verify("challenge") == false)
                throw new SignRequestSignatureException("Invalid signature in NetscapeCertRequest, popo-verification failed.");
            cat.debug("POPO verification succesful");
            ISignSessionRemote ss = home.create();
            X509Certificate cert = (X509Certificate) ss.createCertificate(username, password, nscr.getPublicKey());
            //Certificate[] chain = ss.getCertificateChain();
            cat.info("Created certificate for "+ username);
            debug.print("<h4>Generated certificate:</h4>");
            debug.printInsertLineBreaks(cert.toString().getBytes());
            /*
            // Make sequence of certificates
            DERConstructedSequence seq = new DERConstructedSequence();
            ByteArrayInputStream bIn = new ByteArrayInputStream(cert.getEncoded());
            DERInputStream dIn = new DERInputStream(bIn);
            DERObject obj = dIn.readObject();
            seq.addObject(obj);
            for (int i = 0; i<chain.length; i++) {
                ByteArrayInputStream bIn1 = new ByteArrayInputStream(chain[i].getEncoded());
                DERInputStream dIn1 = new DERInputStream(bIn1);
                DERObject obj1 = dIn1.readObject();
                seq.addObject(obj1);
            }
            // Make PKCS7 ContentInfo for Netscape
            DERConstructedSequence pkcs7 = new DERConstructedSequence();
            // netscape-cert-sequence OBJECT IDENTIFIER :: = { netscape-data-type 5 }
            pkcs7.addObject(new DERObjectIdentifier("2.16.840.1.113730.5"));
            pkcs7.addObject(new DERTaggedObject(0, seq));
            // Now create the DER-datastream
            ByteArrayOutputStream   bOut = new ByteArrayOutputStream();
            DEROutputStream         dOut = new DEROutputStream(bOut);
            dOut.writeObject(pkcs7);
            dOut.close();
            byte[]  bytes = bOut.toByteArray();
             */
            byte[] bytes = cert.getEncoded();
            return bytes;
    } //nsCertRequest

    /**
     * Handles PKCS10 certificate request, these are constructed as:
     * <pre><code>
     * CertificationRequest ::= SEQUENCE {
     * certificationRequestInfo  CertificationRequestInfo,
     * signatureAlgorithm          AlgorithmIdentifier{{ SignatureAlgorithms }},
     * signature                       BIT STRING
     * }
     * CertificationRequestInfo ::= SEQUENCE {
     * version             INTEGER { v1(0) } (v1,...),
     * subject             Name,
     * subjectPKInfo   SubjectPublicKeyInfo{{ PKInfoAlgorithms }},
     * attributes          [0] Attributes{{ CRIAttributes }}
     * }
     * SubjectPublicKeyInfo { ALGORITHM : IOSet} ::= SEQUENCE {
     * algorithm           AlgorithmIdentifier {{IOSet}},
     * subjectPublicKey    BIT STRING
     * }
     * </pre>
     *
     * PublicKey's encoded-format has to be RSA X.509.
     */
    private byte[] pkcs10CertRequest(byte[] b64Encoded, String username, String password, Debug debug)
        throws Exception {
        X509Certificate cert;
        {
            byte[] buffer;
            try {
                // A real PKCS10 PEM request
                String beginKey = "-----BEGIN CERTIFICATE REQUEST-----";
                String endKey = "-----END CERTIFICATE REQUEST-----";
                buffer = FileTools.getBytesFromPEM(b64Encoded, beginKey, endKey);
            } catch (IOException e) {
                try {
                    // Keytool PKCS10 PEM request
                    String beginKey = "-----BEGIN NEW CERTIFICATE REQUEST-----";
                    String endKey = "-----END NEW CERTIFICATE REQUEST-----";
                    buffer = FileTools.getBytesFromPEM(b64Encoded, beginKey, endKey);
                } catch (IOException ioe) {
                    // IE PKCS10 Base64 coded request
                    buffer = Base64.decode(b64Encoded);
                }
            }
            ISignSessionRemote ss = home.create();
            cert = (X509Certificate) ss.createCertificate(username, password, buffer);
            cat.info("Created certificate for " + username);

        }
        debug.print("<h4>Generated certificate:</h4>");
        debug.printInsertLineBreaks(cert.toString().getBytes());
        return Base64.encode(cert.getEncoded());
    } //ieCertRequest

    /**
     * Prints debug info back to browser client
     **/
    private class Debug {
        final private ByteArrayOutputStream buffer;
        final private PrintStream printer;
        Debug( ){
            buffer=new ByteArrayOutputStream();
            printer=new PrintStream(buffer);

            print("<html>");
            print("<body>");
            print("<head>");

            String title = "EJBCA cert request servlet";
            print("<title>" + title + "</title>");
            print("</head>");
            print("<body bgcolor=\"white\">");

            print("<h2>" + title + "</h2>");
        }

        void printDebugInfo(OutputStream out) throws IOException {
            print("</body>");
            print("</html>");
            out.write(buffer.toByteArray());
        }

        void print(Object o) {
            printer.println(o);
        }
        void printMessage(String msg) {
            print("<p>"+msg);
        }
        void printInsertLineBreaks( byte[] bA ) throws Exception {
            BufferedReader br=new BufferedReader(
                new InputStreamReader(new ByteArrayInputStream(bA)) );
            while ( true ){
                String line=br.readLine();
                if (line==null)
                    break;
                print(line.toString()+"<br>");
            }
        }
        void takeCareOfException(Throwable t ) {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            t.printStackTrace(new PrintStream(baos));
            print("<h4>Exception:</h4>");
            try {
                printInsertLineBreaks( baos.toByteArray() );
            } catch (Exception e) {
                e.printStackTrace(printer);
            }
        }
        void ieCertFix(byte[] bA) throws Exception {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            PrintStream tmpPrinter=new PrintStream(baos);
            ieCertFormat(bA, tmpPrinter);
            printInsertLineBreaks(baos.toByteArray());
        }
    } // Debug

} // CertReqServlet

